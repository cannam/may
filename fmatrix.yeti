module fmatrix;

vec = load fvector;

zeroMatrix rows cols = array (map \(vec.zeros cols) [1..rows]);

generateMatrix f rows cols =
   (m = zeroMatrix rows cols;
    for [0..rows-1] do row:
        for [0..cols-1] do col:
            m[row][col] := f row col;
        done;
    done;
    m);

constMatrix n = generateMatrix do row col: n done;
randomMatrix = generateMatrix do row col: Math#random() done;
identityMatrix = constMatrix 1;

width m = if length m > 0 then vec.vectorLength m[0] else 0 fi;
cols = width;

height m = length m;
rows = height;

dimensions m = { cols = width m, rows = height m };

copyOfMatrix m = array (map vec.copyOfVector m);

transposed m is array<~double[]> -> array<~double[]> = 
    generateMatrix do row col: m[col][row] done (cols m) (rows m);
        
interleaved m = 
   ({ cols, rows } = dimensions m;
    v = vec.zeros (cols * rows);
    for [0..rows-1] do row:
        for [0..cols-1] do col:
            v[col * rows + row] := m[row][col];
        done;
    done;
    v);

deinterleaved rows v is number -> ~double[] -> array<~double[]> =
    generateMatrix do row col:
        v[rows * col + row]
    done rows ((vec.vectorLength v) / rows);

mixedDown m =
   (if empty? m then vec.zeros 0 else
        { cols, rows } = dimensions m;
        v = vec.copyOfVector m[0];
        for [1..rows-1] do row:
            for [0..cols-1] do col:
                v[col] := v[col] + m[row][col];
            done;
        done;
        v;
    fi);

mixedDownFromInterleaved rows v is number -> ~double[] -> ~double[] =
   (cols = ((vec.vectorLength v) / rows);
    v' = vec.zeros cols;
    for [0..rows-1] do row:
        for [0..cols-1] do col:
            v'[col] := v'[col] + v[col * rows + row];
        done;
    done;
    v');

{
generateMatrix, constMatrix, randomMatrix, zeroMatrix, identityMatrix,
width, cols, height, rows, dimensions,
copyOfMatrix,
transposed, interleaved, deinterleaved,
mixedDown, mixedDownFromInterleaved,
}

