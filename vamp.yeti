module vamp;

import org.vamp_plugins:
       Plugin, Plugin$InputDomain,
       PluginLoader, PluginLoader$AdapterFlags,
       ParameterDescriptor, OutputDescriptor,
       RealTime, Feature;

import java.lang: UnsatisfiedLinkError;

import java.util: TreeMap, AbstractList;

block = load block;
fr = load framer;
af = load audiofile;

listPlugins () =
   (try
        map string PluginLoader#getInstance()#listPlugins();
    catch UnsatisfiedLinkError e:
        eprintln "Warning: Unable to obtain plugin list:\n\(e)";
        [];
    yrt);
   
categoryOf key =
    list PluginLoader#getInstance()#getPluginCategory(key);

parameterDescriptor pd is ~ParameterDescriptor -> 'a = {
    identifier = pd#identifier,
    name = pd#name,
    description = pd#description,
    unit = pd#unit,
    minValue = pd#minValue,
    maxValue = pd#maxValue,
    defaultValue = pd#defaultValue,
    isQuantized = pd#isQuantized,
    quantizeStep = pd#quantizeStep,
    valueNames = map string pd#valueNames
    };

outputDescriptor od is ~OutputDescriptor -> 'a = {
    identifier = od#identifier,
    name = od#name,
    description = od#description,
    unit = od#unit,
    hasFixedBinCount = od#hasFixedBinCount,
    binCount = od#binCount,
    binNames = map string od#binNames,
    hasKnownExtents = od#hasKnownExtents,
    minValue = od#minValue,
    maxValue = od#maxValue,
    isQuantized = od#isQuantized,
    quantizeStep = od#quantizeStep,
    sampleType = od#sampleType,
    sampleRate = od#sampleRate,
    hasDuration = od#hasDuration,
    };

plugin key p is string -> ~Plugin -> 'a = {
    plugin = p,
    key,
    get apiVersion () = p#getVampApiVersion(),
    get identifier () = p#getIdentifier(),
    get name () = p#getName(),
    get description () = p#getDescription(),
    get maker () = p#getMaker(),
    get copyright () = p#getCopyright(),
    get version () = p#getPluginVersion(),
    get category () = PluginLoader#getInstance()#getPluginCategory(key),
    get parameters () = map parameterDescriptor p#getParameterDescriptors(),
    parameter identifier = p#getParameter(identifier),
    setParameter identifier value = p#setParameter(identifier, value),
    get programs () = map string p#getPrograms(),
    get currentProgram () = p#getCurrentProgram(),
    selectProgram pr = p#selectProgram(pr),
    get inputDomain () = p#getInputDomain(),
    get preferredBlockSize () = p#getPreferredBlockSize(),
    get preferredStepSize () = p#getPreferredStepSize(),
    get minChannelCount () = p#getMinChannelCount(),
    get maxChannelCount () = p#getMaxChannelCount(),
    initialise channels blocksize hop = p#initialise(channels, blocksize, hop),
    reset () = p#reset(),
    get outputs () = map outputDescriptor p#getOutputDescriptors(),
    process floats time is ~float[][] -> ~RealTime -> 'a = p#process(floats, 0, time),
    dispose () = p#dispose(),
    };
/*
realTime r is ~RealTime -> 'a = {
    get sec () = r#sec(),
    get nsec () = r#nsec(),
    get toString () = r#toString(),
    };
*/

realTime r is ~RealTime -> number = r#sec() + (r#nsec() / 1000000000);

//!!!
foldHash f h l is ('a -> hash<'b, 'c>) -> hash<'b, 'c> -> list?<'a> -> hash<'b, 'c> =
   ( for l do x: insertHash h (f x) done; h; );

//!!!
hashFromKeys f kk is ('a -> 'b) -> list?<'a> -> hash<'a, 'b> =
    foldHash do k: [ k: f k ] done [:] kk;

numberOf n is ~Object -> number = (n unsafely_as ~Integer)#intValue();

feature f is ~Feature -> 'a = {
    get timestamp () = if f#hasTimestamp then Time (realTime f#timestamp) else Untimed () fi,
    get duration () = if f#hasDuration then Time (realTime f#duration) else Untimed () fi,
    get values () = list f#values,
    get label () = f#label,
    };

featureList fl is ~Object -> 'a =
   (a = fl unsafely_as ~AbstractList;
    result = array [];
    itr = a#iterator();
    itr#hasNext() loop (push result (feature (itr#next() unsafely_as ~Feature)));
    list result);

featureSet f is ~TreeMap -> 'a =
    hashFromKeys do k: featureList f#get(k as ~Integer) done
       (map do n: numberOf n done (list f#keySet()#toArray()));

loadPlugin key rate =
    plugin key PluginLoader#getInstance()#loadPlugin(key, rate, PluginLoader$AdapterFlags#ADAPT_INPUT_DOMAIN + PluginLoader$AdapterFlags#ADAPT_CHANNEL_COUNT);

processed { p, sampleRate, hop } frames count =
    case frames of
        this::rest:
            p.process
                ([block.floats this] as ~float[][])
                RealTime#frame2RealTime(count, sampleRate)
            :.
            \(processed { p, sampleRate, hop } rest (count + hop));
        _: 
           (p.dispose ();
            []);
    esac;

converted = map featureSet;

process key stream =
   (p = loadPlugin key stream.sampleRate;
    blockSize = p.preferredBlockSize;
    hop = p.preferredStepSize;
    if p.initialise 1 blockSize hop then
        converted
           (processed
            { p, sampleRate = stream.sampleRate, hop } 
            (fr.frames { framesize = blockSize, hop } stream)
            0);
    else
        p.dispose();
        [];
    fi);

processFile key filename =
   (stream = af.open filename;
    p = loadPlugin key stream.sampleRate;
    blockSize = p.preferredBlockSize;
    hop = p.preferredStepSize;
    if p.initialise 1 blockSize hop then
        converted
           (processed
            { p, sampleRate = stream.sampleRate, hop } 
            (fr.frames { framesize = blockSize, hop } stream)
            0);
    else
        p.dispose();
        stream.close();
        [];
    fi);

{
get pluginKeys = listPlugins,
loadPlugin,
categoryOf,
process,
processFile,
}

