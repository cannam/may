
/**
 * Vectors. A May vector is a typesafe, immutable wrapper around a Java
 * primitive array of doubles.
 *
 * Although not as convenient and flexible as a Yeti array<number> or
 * list<number>, a vector can be faster and more compact when dealing
 * with dense data of suitable range and precision such as sampled
 * sequences.
 */

module may.vector;

load may.vector.type;

import java.util: Arrays;

/// Return a vector of n zeros.
zeros n =
    new double[n];

/// Return a vector of length n, containing all m.
consts m n =
   (a = zeros n;
    d = [m] as ~double[];
    Arrays#fill(a, d[0]); //!!! wanted "m as ~double", compiler didn't like it
    a);

/// Return a vector of length n, containing all ones.
ones n = consts 1.0 n;

/// Return a vector of the values in the given list.
fromList l is list?<number> -> ~double[] =
    l as ~double[];

/// Return the given vector as a list.
list' a is ~double[] -> list<number> =
    list a;

/// Return the given vector as a Yeti array.
array' a is ~double[] -> array<number> =
    array a;

/// Return the length of the given vector.
length' =
    length . list';

/// Return true if the given vector is empty (has length 0).
empty?' =
    empty? . list';

/// Return element n in the given vector v. (The function name and
/// argument order are chosen for symmetry with the similar standard
/// library array function.)
at' v n is ~double[] -> number -> number =
    v[n];

/// Return the given vector as a Java primitive float array.
floats a is ~double[] -> ~float[] =
   (len = length' a;
    f = new float[len];
    for [0..len-1] do i:
        f[i] := a[i];
    done;
    f);

/// Return a vector of the values in the given Java primitive float array.
fromFloats ff is ~float[] -> ~double[] =
   (len = length (list ff);
    a = new double[len];
    for [0..len-1] do i:
        a[i] := ff[i];
    done;
    a);

/// Return true if the given vectors are equal, using the standard ==
/// comparator on their elements.
equal v1 v2 =
    list' v1 == list' v2;

/// Return true if the given vectors are equal, when applying the
/// given numerical comparator to each element.
equalUnder comparator v1 v2 =
    length' v1 == length' v2 and
        all id (map2 comparator (list' v1) (list' v2));

/// Return another copy of the given vector.
copyOf v is ~double[] -> ~double[] =
    Arrays#copyOf(v, list' v |> length);

/// Return a new vector containing a subset of the elements of the
/// given vector, from index start (inclusive) to index end
/// (exclusive). (The function name and argument order are chosen for
/// symmetry with the standard library slice and strSlice functions.)
slice v start end is ~double[] -> number -> number -> ~double[] =
    if start < 0 then slice v 0 end
    elif start > length' v then slice v (length' v) end
    else
        if end < start then slice v start start
        elif end > length' v then slice v start (length' v)
        else
            Arrays#copyOfRange(v, start, end);
        fi
    fi;

/// Return a new vector of length n, containing the contents of the
/// given vector v. If v is longer than n, the contents will be
/// truncated; if shorter, they will be padded with zeros.
resizedTo n v is number -> ~double[] -> ~double[] =
    Arrays#copyOf(v, n);

/// Return a new vector that is the reverse of the given vector.  Name
/// chosen (in preference to passive "reversed") for symmetry with the
/// standard library list reverse function.
reverse v is ~double[] -> ~double[] =
   (len = length (list v);
    a = new double[len];
    for [0..len-1] do i:
        a[len-i-1] := v[i];
    done;
    a);

/// Return a single new vector that contains the contents of all the
/// given vectors, in order. (Unlike the standard module list concat
/// function, this one cannot be lazy.)
concat vv is list?<~double[]> -> ~double[] =
    if empty? vv then zeros 0
    else
        len = sum (map length' vv);
        v0 = head vv;
        vout = Arrays#copyOf(v0, len);
        var base = length' v0;
        for (tail vv) do v: 
            vlen = length' v;
            System#arraycopy(v, 0, vout, base, vlen);
            base := base + vlen;
        done;
        vout;
    fi;

/// Return a single new vector that contains the contents of the given
/// vector, repeated n times. The vector will therefore have length n
/// times the length of v.
repeated v n is ~double[] -> number -> ~double[] =
    concat (map \(v) [1..n]);

{
    zeros,
    consts,
    ones,
    vector v = v,
    primitive = copyOf,
    floats,
    fromFloats,
    fromList,
    list = list',
    array = array',
    length = length',
    empty? = empty?',
    at = at',
    equal,
    equalUnder,
    slice,
    resizedTo,
    reverse,
    repeated,
    concat,
} as {
    zeros is number -> vector,
    consts is number -> number -> vector,
    ones is number -> vector,
    vector is ~double[] -> vector,
    primitive is vector -> ~double[],
    floats is vector -> ~float[],
    fromFloats is ~float[] -> vector,
    fromList is list?<number> -> vector,
    list is vector -> list<number>,
    array is vector -> array<number>,
    length is vector -> number,
    empty? is vector -> boolean,
    at is vector -> number -> number,
    equal is vector -> vector -> boolean,
    equalUnder is (number -> number -> boolean) -> vector -> vector -> boolean,
    slice is vector -> number -> number -> vector,
    resizedTo is number -> vector -> vector,
    reverse is vector -> vector,
    repeated is vector -> number -> vector,
    concat is list?<vector> -> vector,
}



