
module audiofile;

import javax.sound.sampled:
     AudioSystem, AudioInputStream, AudioFormat, AudioFormat$Encoding,
     UnsupportedAudioFileException;

import java.io: File, IOException;

import java.nio: ByteBuffer, ByteOrder;

mat = load fmatrix;
ch = load channels;

decode8u bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (for [0..n-1] do i:
       doubles[i] := (bytes[i] / 128.0) - 1.0;
    done
   );

decode16s bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (bb = ByteBuffer#wrap(bytes, 0, n * 2);
    bb#order(ByteOrder#LITTLE_ENDIAN);
    for [0..n-1] do i:
       doubles[i] := bb#getShort(i*2) / 32768.0;
    done
   );

decode32f bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (bb = ByteBuffer#wrap(bytes, 0, n * 4);
    bb#order(ByteOrder#LITTLE_ENDIAN);
    for [0..n-1] do i:
       doubles[i] := bb#getFloat(i*4);
    done
   );

decodeFail () = 
    throw new UnsupportedAudioFileException("File format not supported. Supported formats are 8-bit unsigned PCM, 16-bit signed little-endian PCM, or IEEE float");

decode { format is ~AudioFormat } bytes doubles n = 
   (if format#isBigEndian() then
        decodeFail()
    else
        enc = format#getEncoding();
        bits = format#getSampleSizeInBits();
        if bits == 32 then
            decode32f bytes doubles n;
        elif bits == 16 and enc == AudioFormat$Encoding#PCM_SIGNED then
            decode16s bytes doubles n;
        elif bits == 8 and enc == AudioFormat$Encoding#PCM_UNSIGNED then
            decode8u bytes doubles n;
        else
            decodeFail();
        fi
    fi);

readInterleaved' { format is ~AudioFormat, stream is ~AudioInputStream } nframes =
   (channels = format#getChannels();
    bytesPerSample = format#getSampleSizeInBits() / 8;
    bytes = new byte[nframes * channels * bytesPerSample];
    bytesRead = stream#read(bytes);
    if bytesRead <= 0 then new double[0];
    else
        n = int(bytesRead / bytesPerSample);
        doubles = new double[n];
        decode { format } bytes doubles n;
        doubles;
    fi;
   );

read' { format is ~AudioFormat, stream is ~AudioInputStream } n =
   (doubles = readInterleaved' { format, stream } n;
    channels = format#getChannels();
    ch.deinterleaved channels doubles;
   );

readMono' { format is ~AudioFormat, stream is ~AudioInputStream } n =
   (doubles = readInterleaved' { format, stream } n;
    channels = format#getChannels();
    ch.mixedDownFromInterleaved channels doubles;
   );

// Note, all this assumes the stream is non-blocking (i.e. available()
// is to the end of file)

available' { format is ~AudioFormat, stream is ~AudioInputStream } =
    stream#available() / ((format#getSampleSizeInBits() / 8) * format#getChannels());

readAllInterleaved' { format is ~AudioFormat, stream is ~AudioInputStream } =
    readInterleaved' { format, stream } (available' { format, stream });

readAll' { format is ~AudioFormat, stream is ~AudioInputStream } =
    read' { format, stream } (available' { format, stream });

readAllMono' { format is ~AudioFormat, stream is ~AudioInputStream } =
    readMono' { format, stream } (available' { format, stream });

finished?' { stream is ~AudioInputStream } =
    not (stream#available() > 0);

close' { stream is ~AudioInputStream } =
    stream#close();

open name is string -> 'a = 
   (f = new File(name);
    stream = AudioSystem#getAudioInputStream(f);
    format = stream#getFormat();
    {
        stream,
        format,
        get channels () = format#getChannels(),
        get sampleRate () = format#getSampleRate(),
        get available () = available' { stream, format },
        get finished? () = finished?' { stream },
        read = read' { stream, format },
        readAll () = readAll' { stream, format },
        readInterleaved = readInterleaved' { stream, format },
        readAllInterleaved () = readAllInterleaved' { stream, format },
        readMono = readMono' { stream, format },
        readAllMono () = readAllMono' { stream, format },
        close () = close' { stream },
    } );

{
    open
}

