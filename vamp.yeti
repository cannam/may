module vamp;

import org.vamp_plugins:
       Plugin, Plugin$InputDomain,
       PluginLoader, PluginLoader$AdapterFlags,
       ParameterDescriptor, OutputDescriptor, OutputDescriptor$SampleType,
       RealTime, Feature;

import java.lang: UnsatisfiedLinkError;

import java.util: TreeMap, AbstractList;

block = load block;
fr = load framer;
af = load audiofile;

realTime r is ~RealTime -> number = r#sec() + (r#nsec() / 1000000000);

feature f is ~Feature -> 'a = {
    get timestamp () = if f#hasTimestamp then Time (realTime f#timestamp) else Untimed () fi,
    get duration () = if f#hasDuration then Time (realTime f#duration) else Untimed () fi,
    get values () = list f#values,
    get label () = f#label,
    };

featureList fl is ~Object -> 'a =
    if nullptr? fl then []
    else
        a = fl unsafely_as ~AbstractList;
        result = array [];
        itr = a#iterator();
        itr#hasNext() loop (push result (feature (itr#next() unsafely_as ~Feature)));
        list result
    fi;

numberOf n is ~Object -> number =
   (n unsafely_as ~Integer)#intValue();

featureSet fs is ~TreeMap -> 'a =
   (s = [:];
    kk = list fs#keySet()#toArray(); //!!! ugh
    for kk do k: s[numberOf k] := featureList fs#get(k) done;
    s);

listPlugins () =
   (try
        map string PluginLoader#getInstance()#listPlugins();
    catch UnsatisfiedLinkError e:
        eprintln "Warning: Unable to obtain plugin list:\n\(e)";
        [];
    yrt);
   
categoryOf key =
    list PluginLoader#getInstance()#getPluginCategory(key);

inputDomain d is ~Plugin$InputDomain -> 'a = 
    if d == Plugin$InputDomain#FREQUENCY_DOMAIN then
        FrequencyDomain ()
    else
        TimeDomain ()
    fi;

parameterDescriptor pd is ~ParameterDescriptor -> 'a = {
    identifier = pd#identifier,
    name = pd#name,
    description = pd#description,
    unit = pd#unit,
    minValue = pd#minValue,
    maxValue = pd#maxValue,
    defaultValue = pd#defaultValue,
    isQuantized = pd#isQuantized,
    quantizeStep = pd#quantizeStep,
    valueNames = map string pd#valueNames
    };

sampleType t is ~OutputDescriptor$SampleType -> 'a =
    if t == OutputDescriptor$SampleType#OneSamplePerStep then
        OneSamplePerStep ()
    elif t == OutputDescriptor$SampleType#FixedSampleRate then
        FixedSampleRate ()
    else
        VariableSampleRate ()
    fi;

outputDescriptor od is ~OutputDescriptor -> 'a = {
    identifier = od#identifier,
    name = od#name,
    description = od#description,
    unit = od#unit,
    hasFixedBinCount = od#hasFixedBinCount,
    binCount = od#binCount,
    binNames = map string od#binNames,
    hasKnownExtents = od#hasKnownExtents,
    minValue = od#minValue,
    maxValue = od#maxValue,
    isQuantized = od#isQuantized,
    quantizeStep = od#quantizeStep,
    sampleType = sampleType od#sampleType,
    sampleRate = od#sampleRate,
    hasDuration = od#hasDuration,
    };

plugin key p is string -> ~Plugin -> 'a = {
    plugin = p,
    key,
    get apiVersion () = p#getVampApiVersion(),
    get identifier () = p#getIdentifier(),
    get name () = p#getName(),
    get description () = p#getDescription(),
    get maker () = p#getMaker(),
    get copyright () = p#getCopyright(),
    get version () = p#getPluginVersion(),
    get category () = PluginLoader#getInstance()#getPluginCategory(key),
    get parameters () = array (map parameterDescriptor p#getParameterDescriptors()),
    parameter identifier = p#getParameter(identifier),
    setParameter identifier value = p#setParameter(identifier, value),
    get programs () = array (map string p#getPrograms()),
    get currentProgram () = p#getCurrentProgram(),
    selectProgram pr = p#selectProgram(pr),
    get inputDomain () = inputDomain p#getInputDomain(),
    get preferredBlockSize () = p#getPreferredBlockSize(),
    get preferredStepSize () = p#getPreferredStepSize(),
    get minChannelCount () = p#getMinChannelCount(),
    get maxChannelCount () = p#getMaxChannelCount(),
    initialise { channels, blocksize, hop } = p#initialise(channels, hop, blocksize),
    reset () = p#reset(),
    get outputs () = array (map outputDescriptor p#getOutputDescriptors()),
    process blocks time is 'a -> ~RealTime -> 'b = 
        featureSet p#process((map block.floats blocks) as ~float[][], 0, time),
    getRemainingFeatures () = featureSet p#getRemainingFeatures(),
    dispose () = p#dispose(),
    };

featuresFromSet outputNo f = if outputNo in f then f[outputNo] else [] fi;

outputNumberByName p name =
   (outputs = p.outputs;
    index (head (find ((== name) . (.identifier)) outputs)) outputs);

loadPlugin rate key =
    plugin key PluginLoader#getInstance()#loadPlugin(key, rate, PluginLoader$AdapterFlags#ADAPT_INPUT_DOMAIN + PluginLoader$AdapterFlags#ADAPT_CHANNEL_COUNT);

processed { p, sampleRate, hop } frames count =
    case frames of
        frame::rest:
            p.process [frame] RealTime#frame2RealTime(count, sampleRate)
            :.
            \(processed { p, sampleRate, hop } rest (count + hop));
        _: 
           (rf = p.getRemainingFeatures ();
            p.dispose ();
            [rf]);
    esac;

converted { p, sampleRate, hop } outputNo fl =
    map (featuresFromSet outputNo) fl;

process key output stream =
   (p = loadPlugin stream.sampleRate key;
    blockSize = p.preferredBlockSize;
    hop = p.preferredStepSize;
    outputNo = outputNumberByName p output;
    params = {
        p,
        sampleRate = stream.sampleRate, channels = 1,
        framesize = blockSize, blocksize = blockSize, hop
    };
    if p.initialise params then
        converted params outputNo(processed params (fr.frames params stream) 0);
        // If processing completed successfully, then p is disposed by
        // processed and stream is closed by the framer
    else
        p.dispose();
        stream.close();
        [];
    fi);

processFile key output filename = process key output (af.open filename);

{
get pluginKeys = listPlugins,
loadPlugin,
categoryOf,
process,
processFile,
}

