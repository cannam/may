
module may.stream.test.test_filter;

vec = load may.vector;
bf = load may.vector.blockfuncs;
mat = load may.matrix;
cplx = load may.complex;
fft = load may.transform.fft;
syn = load may.stream.syntheticstream;
filt = load may.stream.filter;

//pl = load may.plot;//!!!

pl = { plot things = true; };

{ compare, compareUsing } = load may.test.test;

compareClose = compareUsing 
    do m1 m2:
        all id (map2 do v1 v2:
            all id (map2 do a b: abs(a - b) < 1e-10 done v1 v2)
        done m1 m2)
    done;

convolutionOptions = [
    [],
    [ Fast false ],
    [ Fast true ],
    [ Fast true, Framesize 1 ],
    [ Fast true, Framesize 2 ],
    [ Fast true, Framesize 16 ]
];

makeTests name withUnknown =
   (maybeDuration n str =
        // Truncate a stream, but if withUnknown is true, return it
        // with availability Unknown -- so as to test that other
        // filter functions behave correctly even if availability is
        // not known on their underlying streams
       (ts = filt.withDuration n str;
        if withUnknown then
            ts with
            { 
                get available () = if ts.finished? then Known 0 else Unknown () fi;
            }
        else
            ts
        fi);
    maybeKnown n =
        if withUnknown then
            Unknown ()
        else
            Known n
        fi;
[

"truncatedTo-\(name)": \(
    // not using withDuration wrapper above, because we're actually
    // testing filt.withDuration here rather than just generating a
    // stream for use in another test
    str = filt.withDuration 3 (syn.generated 2 id);
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Known 3) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,1,2 ] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"truncatedTo-b-\(name)": \(
    // as above
    str = filt.withDuration 3 (syn.generated 2 id);
    compare str.position 0 and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 0,1 ] and
        compare str.position 2 and
        compare str.available (Known 1) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 2 ] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"extendedTo-\(name)": \(
    // not using withDuration wrapper above for the outer call, because
    // we're actually testing filt.withDuration here rather than just
    // generating a stream for use in another test. The inner call
    // does use the wrapper.
    str = filt.withDuration 5 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Known 5) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,1,2,0 ] and
        compare str.position 4 and
        compare str.available (Known 1) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 0 ] and
        compare str.position 5 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-0-3-\(name)": \(
    str = filt.delayedBy 0 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,1,2 ] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-0-inf-\(name)": \(
    str = filt.delayedBy 0 (syn.generated 2 id);
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,1,2,3 ] and
        compare str.position 4 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        ( str.close (); true )
),

"delayedBy-2-3-\(name)": \(
    str = filt.delayedBy 2 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 5) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,0,0,1 ] and
        compare str.position 4 and
        compare str.available (maybeKnown 1) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 2 ] and
        compare str.position 5 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-m2-3-\(name)": \(
    str = filt.delayedBy (-2) (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 1) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 2 ] and
        compare str.position 1 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-m4-3-\(name)": \(
    str = filt.delayedBy (-4) (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Known 0) and
        compare str.finished? true and 
        //!!! with this and others, need to check that we read an empty matrix after finished (perhaps have a helper function that checks finished properties such as available count as well)
        ( str.close (); true )
),

"delayedBy-2-3b-\(name)": \(
    str = filt.delayedBy 2 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 5) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 1))) [ 0 ] and
        compare str.position 1 and
        compare str.available (maybeKnown 4) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 4))) [ 0,0,1,2 ] and
        compare str.position 5 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-2-3c-\(name)": \(
    str = filt.delayedBy 2 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 5) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 7))) [ 0,0,0,1,2 ] and
        compare str.position 5 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"delayedBy-2-inf-\(name)": \(
    str = filt.delayedBy 2 (syn.generated 2 id);
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 0,0 ] and
        compare str.position 2 and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 0,1 ] and
        compare str.position 4 and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 2,3 ] and
        compare str.position 6 and
        compare str.finished? false and
        ( str.close (); true )
),

"delayedBy-m2-inf-\(name)": \(
    str = filt.delayedBy (-2) (syn.generated 2 id);
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (vec.list (mat.getRow 0 (str.read 2))) [ 2,3 ] and
        compare str.position 2 and
        compare str.finished? false and
        ( str.close (); true )
),

"mixedTo-1-2-\(name)": \(
    str = filt.mixedTo 2 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 2 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2],[0,1,2]] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"mixedTo-2-1-\(name)": \(
    str = filt.mixedTo 1
       (filt.multiplexed
          [maybeDuration 3 (syn.generated 2 id),
           maybeDuration 3 (syn.generated 2 id)]);
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2]] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"mixedTo-2-3-\(name)": \(
    str = filt.mixedTo 3
       (filt.multiplexed
          [maybeDuration 3 (syn.generated 2 id),
           maybeDuration 3 (syn.generated 2 (+1))]);
    compare str.position 0 and
        compare str.channels 3 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2],[1,2,3],[0,0,0]] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"mixedTo-1-3-\(name)": \(
    str = filt.mixedTo 3 (maybeDuration 3 (syn.generated 2 id));
    compare str.position 0 and
        compare str.channels 3 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2],[0,1,2],[0,1,2]] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"sum-inf-inf-\(name)": \(
    str = filt.sum [syn.generated 2 (2*), syn.generated 2 (0-)];
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2,3]] and
        compare str.available (Infinite ()) and
        compare str.position 4 and
        ( str.close (); true )
),

"sum-inf-trunc-\(name)": \(
    str = filt.sum [syn.generated 2 (2*), maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 3 and
        ( str.close (); true )
),

"sum-precalc-trunc-\(name)": \(
    str = filt.sum
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[1,1]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"sum-2-1-\(name)": \(
    str = filt.sum
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        filt.multiplexed [syn.precalculatedMono 2 (vec.fromList [3,4]),
                          maybeDuration 3 (syn.generated 2 (0-))]];
    compare str.position 0 and
        compare str.channels 2 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[4,6], [0,-1]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"sum-3-\(name)": \(
    str = filt.sum
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        syn.precalculatedMono 2 (vec.fromList [3,4]),
        maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[4,5]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"multiplexed-inf-inf-\(name)": \(
    str = filt.multiplexed [syn.generated 2 id, syn.generated 2 (0-)];
    compare str.position 0 and
        compare str.channels 2 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4)))
            [[0,1,2,3], [0,-1,-2,-3]] and
        compare str.available (Infinite ()) and
        compare str.position 4 and
        ( str.close (); true )
),

"multiplexed-inf-trunc-\(name)": \(
    str = filt.multiplexed [syn.generated 2 id, maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 2 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[0,1,2], [0,-1,-2]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 3 and
        ( str.close (); true )
),

"multiplexed-precalc-trunc-\(name)": \(
    str = filt.multiplexed
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 2 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[1,2], [0,-1]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"multiplexed-2-1-\(name)": \(
    str = filt.multiplexed
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        filt.multiplexed [syn.precalculatedMono 2 (vec.fromList [3,4]),
                          maybeDuration 3 (syn.generated 2 (0-))]];
    compare str.position 0 and
        compare str.channels 3 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[1,2], [3,4], [0,-1]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"multiplexed-2-1b-\(name)": \(
    str = filt.multiplexed
       [syn.precalculatedMono 2 (vec.fromList [1,2]),
        syn.precalculatedMono 2 (vec.fromList [3,4]),
        maybeDuration 3 (syn.generated 2 (0-))];
    compare str.position 0 and
        compare str.channels 3 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[1,2], [3,4], [0,-1]] and
        compare str.available (Known 0) and
        compare str.finished? true and
        compare str.position 2 and
        ( str.close (); true )
),

"repeated-2-\(name)": \(
    str = filt.repeated
       (syn.precalculatedMono 2 (vec.fromList [1,2,3]));
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 1))) [[1]] and
        compare str.position 1 and
        compare (map vec.list (mat.asRows (str.read 2))) [[2,3]] and
        compare str.position 3 and
        compare (map vec.list (mat.asRows (str.read 3))) [[1,2,3]] and
        compare str.position 6 and
        compare (map vec.list (mat.asRows (str.read 5))) [[1,2,3,1,2]] and
        compare (map vec.list (mat.asRows (str.read 9))) [[3,1,2,3,1,2,3,1,2]] and
        compare (map vec.list (mat.asRows (str.read 2))) [[3,1]] and
        compare str.available (Infinite ()) and
        compare str.finished? false and
        compare str.position 22 and
        ( str.close (); true )
),

"duplicated-1-\(name)": \(
    original = maybeDuration 3 (syn.precalculatedMono 2 (vec.fromList [1,2,3]));
    sn = filt.duplicated 1 original;
    str = (head sn);
    compare (length sn) 1 and
        compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 1))) [[1]] and
        compare str.position 1 and
        compare str.available (maybeKnown 2) and
        compare (map vec.list (mat.asRows (str.read 3))) [[2,3]] and
        compare str.position 3 and
        compare str.finished? true and
        compare str.available (Known 0) and
        ( str.close (); true )
),

"duplicated-2-\(name)": \(
    original = maybeDuration 3 (syn.precalculatedMono 2 (vec.fromList [1,2,3]));
    sn = filt.duplicated 2 original;
    s1 = (head sn);
    s2 = (head (tail sn));

    compare (length sn) 2 and

        compare s1.position 0 and
        compare s1.channels 1 and
        compare s1.sampleRate 2 and
        compare s1.available (maybeKnown 3) and
        compare s1.finished? false and

        compare s2.position 0 and
        compare s2.channels 1 and
        compare s2.sampleRate 2 and
        compare s2.available (maybeKnown 3) and
        compare s2.finished? false and

        compare (map vec.list (mat.asRows (s1.read 1))) [[1]] and
        compare s1.position 1 and
        compare s1.available (maybeKnown 2) and
        compare s2.position 0 and
        compare s2.available (maybeKnown 3) and

        compare (map vec.list (mat.asRows (s2.read 2))) [[1,2]] and
        compare s1.position 1 and
        compare s1.available (maybeKnown 2) and
        compare s2.position 2 and
        compare s2.available (maybeKnown 1) and

        compare (map vec.list (mat.asRows (s1.read 3))) [[2,3]] and
        compare s1.position 3 and
        compare s1.finished? true and
        compare s1.available (Known 0) and
        compare s2.position 2 and
        compare s2.finished? false and
        compare s2.available (Known 1) and // when one is known, so is the other

        compare (map vec.list (mat.asRows (s1.read 3))) [] and

        compare (map vec.list (mat.asRows (s2.read 1))) [[3]] and
        compare s1.position 3 and
        compare s1.finished? true and
        compare s2.position 3 and
        compare s2.finished? true and

        ( s1.close (); s2.close() ; true )
),

"convolvedImpulse-\(name)": \(
    all id
       (map do opts:
            ir = mat.newRowVector (vec.fromList [1,0,-1,0]);
            signal = maybeDuration 4
               (syn.precalculatedMono 2 (vec.fromList [1,0,0,0]));
            c = filt.convolvedWith opts ir signal;
            compareClose (map vec.list (mat.asRows (c.read 4))) [[ 1,0,-1,0 ]] and
               ( c.close (); true )
        done convolutionOptions);
),

"convolvedImpulse2-\(name)": \(
    all id
       (map do opts:
            ir = mat.newRowVector (vec.fromList [8,6,4,2]);
            signal = maybeDuration 4
               (syn.precalculatedMono 2 (vec.fromList [1,0,0,0]));
            c = filt.convolvedWith opts ir signal;
            compareClose (map vec.list (mat.asRows (c.read 4))) [[ 8,6,4,2 ]] and
               ( c.close (); true )
        done convolutionOptions);
),

"convolvedImpulse-multichannel-\(name)": \(
    all id
       (map do opts:
            ir = mat.newMatrix (RowMajor ())
               (map vec.fromList [[0,0,0,1],[8,6,4,2],[1,0,-1,0]]);
            signal = maybeDuration 4
               (syn.precalculated 2 
                   (mat.newMatrix (RowMajor ())
                       (map vec.fromList [[1,1,0,0],[0,1,1,0],[0,0,1,1]])));
            c = filt.convolvedWith opts ir signal;
            compareClose (map vec.list (mat.asRows (c.read 4)))
                [[0,0,0,1],[0,8,14,10],[0,0,1,1]] and
               ( c.close (); true )
        done convolutionOptions);
),

"convolvedWith-\(name)": \(
    all id
       (map do opts:
            fast = not (opts == [ Fast false ]);
            ir = mat.newRowVector (vec.fromList [1,2,3,4,5]);
            signal = maybeDuration 3
               (syn.precalculatedMono 2 (vec.fromList [10,20,30]));
            c = filt.convolvedWith opts ir signal;
            compare c.position 0 and
                compare c.channels 1 and
                compare c.sampleRate 2 and
                (fast or compare c.available (maybeKnown 7)) and
                compareClose (map vec.list (mat.asRows (c.read 3)))
                    [[ 10*1,
                       20*1 + 10*2,
                       30*1 + 20*2 + 10*3 ]] and
                (fast or compare c.available (Known 4)) and
                compare c.finished? false and
                compareClose (map vec.list (mat.asRows (c.read 4)))
                    [[        30*2 + 20*3 + 10*4,
                                     30*3 + 20*4 + 10*5,
                                            30*4 + 20*5,
                                                   30*5 ]] and
                (fast or (compare c.available (Known 0) and
                          compare c.finished? true)) and
                ( c.close (); true )
        done convolutionOptions);
),

"spaced-\(name)": \(
    original = maybeDuration 3 (syn.precalculatedMono 2 (vec.fromList [1,2,3]));
    str = filt.spaced 3 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 9) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 4))) [[1,0,0,2]] and
        compare str.position 4 and
        compare str.available (maybeKnown 5) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 1))) [[0]] and
        compare str.position 5 and
        compare str.available (maybeKnown 4) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 10))) [[0,3,0,0]] and
        compare str.position 9 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

"picked-\(name)": \(
    original = maybeDuration 8 (syn.precalculatedMono 2 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = filt.picked 3 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (maybeKnown 3) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 1))) [[1]] and
        compare str.position 1 and
        compare str.available (maybeKnown 2) and
        compare str.finished? false and
        compare (map vec.list (mat.asRows (str.read 3))) [[4,7]] and
        compare str.position 3 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

//!!! still no tests for filters with multi-channel inputs

]);

knowns = makeTests "known" false;
unknowns = makeTests "unknown" true;

logSpectrumFrom output n =
   (outdata = mat.getRow 0 (output.read n);
    spectrum = cplx.magnitudes (fft.realForward n outdata);
    array (map do v: 20 * Math#log10(v) done (vec.list spectrum)));

makeDiracStream rate n =
    syn.generated rate do x: if x == int(n/2) then 1 else 0 fi done;

filtering = [

"interpolated-sine": \(
    // Interpolating a sinusoid should give us a sinusoid
    //!!! only beyond half the filter length
    sinusoid = syn.sinusoid 8 2; // 2Hz sine sampled at 8Hz: [ 0, 1, 0, -1 ] etc
    input = filt.withDuration 16 sinusoid;
    output = filt.interpolated 2 input;
    result = output.read 32;
    reference = syn.sinusoid 16 2;
    expected = reference.read 32;
    compareOutputs a b = compareClose
       (map vec.list (mat.asRows a)) (map vec.list (mat.asRows b));
    compareOutputs result expected;
),

"decimated-sine": \(
    // Decimating a sinusoid should give us a sinusoid
    //!!! only beyond half the filter length
    sinusoid = syn.sinusoid 32 1; // 1Hz sine sampled at 32Hz
    input = filt.withDuration 400 sinusoid;
    output = filt.decimated 2 input;
    result = mat.columnSlice (output.read 200) 50 150;
    reference = syn.sinusoid 16 1;
    expected = mat.columnSlice (reference.read 200) 50 150;
    compareOutputs a b = compareClose
       (map vec.list (mat.asRows a)) (map vec.list (mat.asRows b));
    if not compareOutputs result expected then
        println "diff: \(mat.difference result expected)";
	false
    else true fi
),

"interpolated-misc": \(
    // Interpolating any signal by N should give a signal in which
    // every Nth sample is the original signal
    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.concat [ data, data ];
    input = filt.withDuration (vec.length data) (syn.precalculatedMono 4 data);
    factor = 3;
    up = filt.interpolated factor input;
    result = mat.getRow 0 (up.read (factor * vec.length data));
    phase = 0;
    a = vec.list data;
    b = map do i: vec.at result (i*factor + phase) done [0..vec.length data - 1];
    compareClose [a] [b];
),

"int-dec": \(
    // Interpolating any signal then decimating by the same factor
    // should get us the original back again
    //!!! no, this is phase dependent
//    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
//    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.fromList [ 0, 1, 2, 3 ];
    data = vec.concat [ data, data ];

    factor = 3;

    updown prepad =
       (input = filt.withDuration (vec.length data) (syn.precalculatedMono 4 data);
        intermediate = filt.interpolated factor input;
        output = filt.decimated factor (filt.delayedBy prepad intermediate);
        output.read (vec.length data));

    result = updown 0;
    if not compareClose [vec.list (mat.getRow 0 result)] [vec.list data] then
        \() (pl.plot [Vector data, 
                      Vector (mat.getRow 0 result), 
                      Vector (mat.getRow 0 (updown 1)),
                      Vector (mat.getRow 0 (updown 2))]);
        up = (filt.interpolated 2 (syn.precalculatedMono 4 data)).read 80;
        \() (pl.plot [Vector (mat.getRow 0 up)]);
        false
    else true fi;
),

"lowpassed-dirac": \(
    test { rate, cutoff, attenuation, bandwidth, n } = 
       (input = makeDiracStream rate n;
        output = filt.lowpassed cutoff attenuation bandwidth input;
        logspec = logSpectrumFrom output n;
        acceptances = map do bin:
            freq = (rate / n) * bin;
            db = logspec[bin];
            //!!! what should these 0.01 actually be?
            if freq < cutoff - bandwidth/2 then (db < 0.01 and db > -0.01)
            elif freq > cutoff + bandwidth/2 then (db < -attenuation)
            else (db < 0.01 and db > -attenuation)
            fi;
        done [0..n/2];
        compare acceptances (map \true [0..n/2]));
    all id 
       (map test [
            { rate = 800, cutoff = 200, attenuation = 80, bandwidth = 10, n = 1000 },
        ]);
),

"highpassed-dirac": \(
    test { rate, cutoff, attenuation, bandwidth, n } = 
       (input = makeDiracStream rate n;
        output = filt.highpassed cutoff attenuation bandwidth input;
        logspec = logSpectrumFrom output n;
        acceptances = map do bin:
            freq = (rate / n) * bin;
            db = logspec[bin];
            //!!! what should these 0.01 actually be?
            if freq > cutoff + bandwidth/2 then (db < 0.01 and db > -0.01)
            elif freq < cutoff - bandwidth/2 then (db < -attenuation)
            else (db < 0.01 and db > -attenuation)
            fi;
        done [0..n/2];
        compare acceptances (map \true [0..n/2]));
    all id 
       (map test [
            { rate = 800, cutoff = 200, attenuation = 80, bandwidth = 10, n = 1000 },
        ]);
),

"bandpassed-dirac": \(
    test { rate, f0, f1, attenuation, bandwidth, n } = 
       (input = makeDiracStream rate n;
        output = filt.bandpassed f0 f1 attenuation bandwidth input;
        logspec = logSpectrumFrom output n;
        acceptances = map do bin:
            freq = (rate / n) * bin;
            db = logspec[bin];
            //!!! what should these 0.01 actually be?
            if freq < f0 - bandwidth/2 then (db < -attenuation)
            elif freq < f0 + bandwidth/2 then (db < 0.01 and db > -attenuation)
            elif freq < f1 - bandwidth/2 then (db < 0.01 and db > -0.01)
            elif freq < f1 + bandwidth/2 then (db < 0.01 and db > -attenuation)
            else (db < -attenuation)
            fi;
        done [0..n/2];
        compare acceptances (map \true [0..n/2]));
    all id 
       (map test [
            { rate = 800, f0 = 200, f1 = 300, attenuation = 80, bandwidth = 10, n = 1000 },
        ]);
),

];    

all = [:];
for [ knowns, unknowns, filtering ] do h:
    for (keys h) do k: all[k] := h[k] done
done;

all is hash<string, () -> boolean>;

