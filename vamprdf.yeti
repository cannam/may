
module vamprdf;

vamp = load vamp;

read = load yertle.read;
{ newRdfStore } = load yertle.store;

import java.io: File;

listVampRdfFiles () =
    concat
       (map do p:
            map ((p ^ File#separator ^) . (.name))
               (filter do entry:
                    entry.file? and
                       (lc = strLower entry.name;
                        (strEnds? lc ".ttl") or
                        (strEnds? lc ".n3") or
                        (strEnds? lc ".nt"))
                    done (listDirectory false p))
            done (vamp.pluginPath));

loadVampRdfStore store =
    for (listVampRdfFiles ()) do file:
        case read.loadTurtleFile store ("file://" ^ file) file of
        OK (): ();
        Error e: eprintln
            "WARNING: Failed to load Vamp plugin RDF file \"\(file)\": \(e)";
        esac
    done;

addVampPrefixes store =
   (store.addPrefix "vamp" "http://purl.org/ontology/vamp/";
    store.addPrefix "dc" "http://purl.org/dc/elements/1.1/";
    store.addPrefix "foaf" "http://xmlns.com/foaf/0.1/";
    store.addPrefix "owl" "http://www.w3.org/2002/07/owl#");


//!!! no, should not have both a global singleton store *and* a
//function that only really exists to modify it!
//(i.e. loadGlobalVampRdf) -- better to load on demand

store = newRdfStore ();
var loaded = false;

getSystemVampRdfStore () =
    synchronized store do:
        if not loaded then
            addVampPrefixes store;
            loadVampRdfStore store;
            loaded := true;
        fi;
        store
    done;

getGlobalPluginIndex () =
    list (strSplit "\n" (fetchURL [ Timeout 10 ] (Handle getContents)
                         "http://www.vamp-plugins.org/rdf/plugins/index.txt"));

//!!! need to cache these retrievals
parseGlobalVampRdf () =
   (parse urls =
        case urls of
        url::rest:
           (doc = fetchURL [ Timeout 10 ] (Handle getContents) url;
            parsed = read.parseTurtleString url doc;
            { url, parsed } :. \(parse rest));
         _: [];
        esac;
    parse (getGlobalPluginIndex ()));

loadGlobalVampRdf store =
    for (parseGlobalVampRdf ()) do { url, parsed }:
        case read.loadParsedTriples store parsed of
        OK (): ();
        Error e: eprintln "WARNING: Failed to load Vamp RDF from URL \(url): \(e)";
        esac;
    done;

filterIRIsFromNodes nodes =
    map do r: case r of IRI iri: iri; esac done
       (filter do r: case r of IRI iri: true; _: false esac done nodes);

subjects = map (.s);

iriTypes = map do t: case t of IRI iri: IRI iri; Blank n: Blank n esac done;

iriSubjects = iriTypes . subjects;

libraryNodes store =
    iriSubjects
       (store.match {
            s = Wildcard (),
            p = Known (store.expand "a"),
            o = Known (store.expand "vamp:PluginLibrary")
            });

pluginNodes store =
    iriSubjects
       (store.match {
            s = Wildcard (),
            p = Known (store.expand "a"),
            o = Known (store.expand "vamp:Plugin")
            });

pluginsWithId store id = 
    iriTypes
       (filter do pnode:
        store.contains {
            s = pnode,
            p = store.expand "vamp:identifier",
            o = Literal { value = id, type = "", language = "" }
            }
        done (pluginNodes store));

librariesWithId store id =
    iriTypes
       (filter do lnode:
        store.contains {
            s = lnode,
            p = store.expand "vamp:identifier",
            o = Literal { value = id, type = "", language = "" }
            }
        done (libraryNodes store));

//!!! better if it took a plugin key? (the soname:label form)
pluginNodesById store libraryId pluginId =
   (candidatePlugins = pluginsWithId store pluginId;
    candidateLibraries = librariesWithId store libraryId;
    filter do pnode:
        any do lnode:
            store.contains {
                s = lnode,
                p = store.expand "vamp:available_plugin",
                o = pnode
                }
            done candidateLibraries
        done candidatePlugins
    );

libraryFor store pluginNode =
    case store.match {
        s = Wildcard (), p = Known (store.expand "vamp:available_plugin"), o = Known pluginNode
        } of
    { s = IRI iri }::others: IRI iri;
    { s = Blank n }::others: Blank n;
     _: None ();
    esac;

textProperty store subject name =
    case store.match {
        s = Known subject, p = Known (store.expand name), o = Wildcard ()
        } of
    { o = Literal { value = text } }::others: text;
     _: "";
    esac;

iriProperty store subject name =
    case store.match {
        s = Known subject, p = Known (store.expand name), o = Wildcard ()
        } of
    { o = IRI iri }::others: IRI iri;
     _: None ();
    esac;

inputDomainOf store pluginNode =
   case store.match {
        s = Known pluginNode, p = Known (store.expand "vamp:input_domain"), o = Wildcard ()
        } of
    { o = IRI iri }::others:
        if IRI iri == store.expand "vamp:FrequencyDomain"
        then FrequencyDomain ()
        else TimeDomain ()
        fi;
     _: TimeDomain ();
    esac;

outputDescriptor store outputNode =
   (tprop abbr = textProperty store outputNode abbr;
    iprop abbr = iriProperty store outputNode abbr;
    bprop abbr deflt =
       (b = strLower (textProperty store outputNode abbr);
        if b == "true" then true elif b == "false" then false else deflt fi);
    nprop abbr =
        try number (textProperty store outputNode abbr); catch Exception _: 0 yrt;
    {
        get identifier () = tprop "vamp:identifier",
        get name () = tprop "dc:title",
        get description () = tprop "dc:description",
        get rdfType () = case iprop "a" of IRI iri: iri; _: "" esac,
        get valueUnit () = tprop "vamp:unit",
        get binCount () = 
            if bprop "vamp:fixed_bin_count" false
            then Known (nprop "vamp:bin_count")
            else Unknown ()
            fi,
        get computes () =
            case iprop "vamp:computes_event_type" of
            IRI iri: Event iri;
             _: case iprop "vamp:computes_signal_type" of
                IRI iri: Signal iri;
                 _: case iprop "vamp:computes_feature_type" of
                    IRI iri: Feature iri;
                     _: Unknown ();
                    esac
                esac
            esac,
        //!!! and some other properties
    });

getPluginData store pluginNode =
   (tprop abbr = textProperty store pluginNode abbr;
    {
    //!!! a plugin key property (i.e. the soname:label thing used to load it) would be handy
        get apiVersion () = tprop "vamp:vamp_API_version", //!!! number not text
        get identifier () = tprop "vamp:identifier",
        get name () = tprop "dc:title",
        get description () = tprop "dc:description",
        get maker () = tprop "foaf:maker", //!!! is an IRI or blank node with a foaf:name property
        get copyright () = tprop "dc:rights",
        get version () = tprop "owl:versionInfo",
        get category () = tprop "vamp:category",
        get inputDomain () = inputDomainOf store pluginNode,
        get infoURL () =
           (case iriProperty store pluginNode "foaf:page" of
            IRI iri: iri;
            None ():
                case libraryFor store pluginNode of
                None (): "";
                IRI iri:
                    case iriProperty store (IRI iri) "foaf:page" of
                    IRI iri: iri;
                    None (): "";
                    esac;
                Blank n:
                    case iriProperty store (Blank n) "foaf:page" of
                    IRI iri: iri;
                    None (): "";
                    esac;
                esac;
            esac),
        get outputs () = 
           (matches = store.match { s = Known pluginNode,
                                    p = Known (store.expand "vamp:output"), 
                                    o = Wildcard () };
            array (map do t:
                       case t.o of
                       IRI iri: outputDescriptor store (IRI iri);
                       Blank n: outputDescriptor store (Blank n);
                       esac
                       done matches)),
    });

//!!! reconsider these names
{
getGlobalPluginIndex,
parseGlobalVampRdf,
loadGlobalVampRdf,
getSystemVampRdfStore,
vampPluginNodes = pluginNodes,
vampLibraryNodes = libraryNodes,
vampPluginNodesById = pluginNodesById,
vampPluginData = getPluginData,
}

