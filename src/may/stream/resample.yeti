
module may.stream.resample;

mat = load may.matrix;
vec = load may.vector;
bf = load may.vector.blockfuncs;
win = load may.signal.window;
manip = load may.stream.manipulate;
convolve = load may.stream.convolve;

load may.stream.type;
load may.vector.type;
load may.matrix.type;

//!!! todo: synchronized for everything with state assignment

/**
  Produce a sinc window of width equal to zc zero crossings per half,
  with n samples from peak to first zero crossing, multiplied by a
  Kaiser window with attenuation alpha dB
 */
kaiserSincWindow zc n alpha =
   (sw = win.sinc (n*2) (n*zc*2 + 1);
    kw = win.kaiserForAttenuation alpha (vec.length sw);
    bf.multiply sw kw);

/**
 * Produce a sinc window with n samples from peak to first zero
 * crossing, multiplied by a Kaiser window with attenuation alpha dB
 * and transition bandwidth Hz at the given sampleRate. The filter
 * will contain an odd number of samples.
 */
kaiserSincFilterFor { n, attenuation, bandwidth, samplerate } =
   (before = System#currentTimeMillis();
    pp = win.kaiserParameters (ByFrequency { attenuation, bandwidth, samplerate });
    length = if pp.length % 2 == 0 then pp.length + 1 else pp.length fi;
    kw = win.kaiser (pp with { length });
    sw = win.sinc (n*2) length;
    filter = bf.multiply sw kw;
    after = System#currentTimeMillis();
    println "filter generation took \(after - before)ms";
    filter);

durationAdjusterFor factor s =
    case s.available of
    Known n: manip.withDuration (int (n * factor));
    _: id;
    esac;

//!!!doc: Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).
   
interpolated factor s = //!!! factor must be an integer [how to enforce this??]
    if factor == 1 then s
    else
        adjuster = durationAdjusterFor factor s;
        nzc = 13;
        attenuation = 80;
        filter = kaiserSincWindow nzc factor attenuation;
        out = adjuster
           (manip.delayedBy (- (nzc * factor))
               (convolve.convolvedWith [Framesize 1024]
                   (mat.newMatrix (RowMajor ()) (map \filter [1..s.channels]))
                   (manip.spaced factor s)));
        out with { get sampleRate () = s.sampleRate * factor };
    fi;

//!!!doc: Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).

decimated factor s = //!!! factor must be an integer [how to enforce this??]
    if factor == 1 then s
    else
        adjuster = durationAdjusterFor (1/factor) s;
        nzc = 13;
        attenuation = 80;
        filter = kaiserSincWindow nzc factor attenuation;
        filtered =
           (convolve.convolvedWith [Framesize 1024]
               (mat.newMatrix (RowMajor ()) (map \filter [1..s.channels])) s);
        out = adjuster
           (manip.scaledBy (1/factor)
               (manip.delayedBy (- nzc)
                   (manip.picked factor filtered)));
        out with { get sampleRate () = s.sampleRate / factor };
    fi;

gcd a b = (c = a % b; if c == 0 then b else gcd b c fi);

/**
 * Resample a stream to the given target rate, using separate successive
 * interpolation and decimation processes. This should give the same 
 * results as resampledDirectlyTo, but in most cases should be slower.
 */
resampledUpDownTo targetRate s =
   (g = gcd targetRate s.sampleRate;
    decimated (s.sampleRate / g) (interpolated (targetRate / g) s));

/**
 * Resample a stream to the given target rate, by applying a single
 * resampling filter directly.
 */
resampledDirectlyTo targetRate s =
   (
    // We need a low-pass filter that will cut off just below the
    // Nyquist frequency at the lower of the two sample rates. This
    // filter needs to be sampled at a sufficient resolution that we
    // can get values from it at every sample point in the source rate
    // and in the target.

    sourceRate = s.sampleRate;
    higher = max sourceRate targetRate;
    lower = min sourceRate targetRate;
    g = gcd higher lower;

    // Example: ratio of 3:4 in sample periods, corresponding to
    // e.g. resampling from 48kHz to 36kHz. The lower rate has the
    // longer sample period. We need a filter with n=4 values from
    // peak to first pole -- this is the longer sample period relative
    // to the shorter and is obtained by dividing the *higher* rate by
    // the gcd (because the ratio of sample periods is the reciprocal
    // of the ratio of sample rates).

    peakToPole = higher / g; // would be 4 in the above example

    // Our filter is a sinc function with peak-to-pole length
    // peakToPole, multiplied by a Kaiser window of transition
    // bandwidth narrow enough at the effective sample rate n to
    // exclude... what?

    fparams = {
        n = peakToPole,
        attenuation = 120,
        bandwidth = (lower / g) / 1000,
        samplerate = (higher / g),
    };

    filt = kaiserSincFilterFor fparams;

    println "for target rate \(targetRate) and source rate \(sourceRate), gcd = \(g) and peakToPole = \(peakToPole), filt parameters \(fparams), filter length \(vec.length filt)";

//filt = kaiserSincWindow 7 peakToPole 80;
//println "temporary: filter length \(vec.length filt)";

    println "for target rate \(targetRate) and source rate \(sourceRate), gcd = \(g) and peakToPole = \(peakToPole), filter length \(vec.length filt)";

    //!!! ponder
/*
    filt = kaiserSincFilterFor {
        n = peakToPole,
        attenuation = 140,
//        bandwidth = 10,
        bandwidth = lower / 100,
        samplerate = lower
    };

    filt = kaiserSincFilterFor {
        n = peakToPole, 
        attenuation = 80, 
        bandwidth = 1, 
        samplerate = higher
    };
*/

    // Now we have a filter of (odd) length flen in which the lower
    // sample rate corresponds to every n'th point and the higher rate
    // to every m'th where n and m are higher and lower rates divided
    // by their gcd respectively. So if x coordinates are on the same
    // scale as our filter resolution, then source sample i is at i *
    // (targetRate / gcd) and target sample j is at j * (sourceRate /
    // gcd).

    // To reconstruct a single target sample, we want a buffer (real
    // or virtual) of flen values formed of source samples spaced at
    // intervals of (targetRate / gcd), in our example case 3.  This
    // is initially formed with the first sample at the filter peak.
    //
    // 0  0  0  0  a  0  0  b  0
    //
    // and of course we have our filter
    //
    // f1 f2 f3 f4 f5 f6 f7 f8 f9
    //
    // We take the sum of products of non-zero values from this buffer
    // with corresponding values in the filter
    //
    // a * f5 + b * f8
    //
    // Then we drop (sourceRate / gcd) values, in our example case 4,
    // from the start of the buffer and fill until it has flen values
    // again
    //
    // a  0  0  b  0  0  c  0  0
    //
    // repeat to reconstruct the next target sample
    //
    // a * f1 + b * f4 + c * f7
    //
    // and so on.
    //
    // Above I said the buffer could be "real or virtual" -- ours is
    // virtual. We don't actually store all the zero spacing values,
    // except for padding at the start; normally we store only the
    // values that actually came from the source stream, along with a
    // phase value that tells us how many virtual zeroes there are at
    // the start of the virtual buffer.  So the two examples above are
    //
    // 0 a b  [ with phase 1 ]
    // a b c  [ with phase 0 ]

    // Get this before we do anything else with s -- we're just
    // retrieving it in order to distinguish between known-duration
    // and unknown-duration streams
    initialAvailable = s.available;

    var remaining = 
        case initialAvailable of
        Known n: int ((n * targetRate) / sourceRate + 0.5);
        other: 0;
        esac;

    flen = vec.length filt;
    halflen = int (flen/2); // actual filter length is halflen + halflen + 1

    inputSpacing = targetRate / g;
    var phase = halflen % inputSpacing;
    
    var buffer = mat.toRowMajor
       (mat.concat (Horizontal ())
           [mat.zeroMatrix { 
                rows = s.channels,
                columns = int (halflen / inputSpacing)
            },
            s.read Math#ceil((halflen + 1) / inputSpacing)
            ]);
            
//    println "initial buffer (for flen = \(flen) and inputSpacing = \(inputSpacing)) with input phase \(phase) is: \(vec.list (mat.getRow 0 buffer))";

    var pos = 0;
    
    reconstructOne rowdata ch n is array<~double[]> -> number -> number -> () =
       (series = mat.getRow ch buffer;
        row = rowdata[ch];
        for [0..(vec.length series)-1] do i:
            a = vec.at series i;
            b = vec.at filt (phase + i * inputSpacing);
            row[n] := row[n] + a * b;
        done);

    expired? () = 
        case initialAvailable of
        Known _: remaining <= 0;
        _: (inputSpacing * mat.width buffer + phase) <= halflen;
        esac;

    fill rowdata n =
        fold do count i: 
            if expired? () then
                count
            else

                for [0..s.channels-1] do ch:
                    reconstructOne rowdata ch i;
                done;
            
                m = sourceRate / g;
    
                // I'm sure the sums for drop, take, phase could be simpler
    
                drop = int Math#ceil((max 0 (m - phase)) / inputSpacing);
                take = int ((m + ((flen - 1 - phase) % inputSpacing))
                            / inputSpacing);
                
                phase := (phase - m);
                phase < 0 loop phase := phase + inputSpacing;
                phase := phase % inputSpacing;

//print "[\(drop):\(take)] ";

                next = s.read take;
                buffer := mat.concat (Horizontal ())
                   [mat.columnSlice buffer drop flen, next];

                remaining := if remaining > 0 then remaining - 1 else 0 fi;
                pos := pos + 1;

                count + 1;
            fi
        done 0 [0..n-1];
    
    s with
    {
        get sampleRate () = targetRate,
        get position () = pos,
        get available () = 
            case initialAvailable of
            Known n: Known remaining;
            other: other;
            esac,
        get finished? () = expired? (),
        read n = 
           (rowdata = array (map \(new double[n]) [1..s.channels]);
println "n = \(n)";
            obtained = fill rowdata n;
            scaleFactor = min 1.0 (targetRate / sourceRate);
            result = mat.newMatrix (RowMajor ())
               (map do r: bf.scaled scaleFactor (vec.vector r) done rowdata);
            if obtained < n then mat.columnSlice result 0 obtained
            else result
            fi)
    });

resampledTo = resampledDirectlyTo;

{
    kaiserSincWindow, kaiserSincFilterFor,
    interpolated, decimated,
    resampledUpDownTo, resampledDirectlyTo,
    resampledTo
}

