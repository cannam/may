
module may.stream.test.test_resample;

vec = load may.vector;
bf = load may.vector.blockfuncs;
mat = load may.matrix;
syn = load may.stream.syntheticstream;
manip = load may.stream.manipulate;
resample = load may.stream.resample;
win = load may.signal.window;
waves = load may.stream.waves;
fft = load may.transform.fft;

pl = load may.plot;//!!!

//pl = { plot things = true; };

{ compare, compareUsing, compareMatrices, assert, time } = load may.test.test;

//!!! This and gcd should be Somewhere
nextPowerOfTwo n =
   (nextPowerOfTwo' p n =
        if p >= n then p
        else nextPowerOfTwo' (p * 2) n
        fi;
    nextPowerOfTwo' 1 n);

windowedSignalFrom stream nsamps =
   (data = stream.read nsamps;
    windowed = win.windowedRows win.hann data;
    syn.precalculated stream.sampleRate windowed);

[

// Test for duration of decimated stream (does not test contents, that
// happens in the filters tests below).
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).

"dec-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.decimated 2 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Known 4) and
        compare str.finished? false and
       (r = str.read 3;
        compare (mat.size r) { rows = 1, columns = 3 }) and
        compare str.position 3 and
        compare str.available (Known 1) and
        compare str.finished? false and
       (r = str.read 3;
        compare (mat.size r) { rows = 1, columns = 1 }) and
        compare str.position 4 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

// Test for duration of interpolated stream (does not test contents,
// that happens in the filters tests below)
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).

"int-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.interpolated 2 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 8 and
        compare str.available (Known 16) and
        compare str.finished? false and
        compare (mat.size (str.read 12)) { rows = 1, columns = 12 } and
        compare str.position 12 and
        compare str.available (Known 4) and
        compare str.finished? false and
        compare (mat.size (str.read 12)) { rows = 1, columns = 4 } and
        compare str.position 16 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

// Test for duration of resampled stream (does not test contents,
// that happens in the filters tests below)
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).
"resamp-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.resampledTo 6 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 6 and
        compare str.available (Known 12) and
        compare str.finished? false and
        compare (mat.size (str.read 9)) { rows = 1, columns = 9 } and
        compare str.position 9 and
        compare str.available (Known 3) and
        compare str.finished? false and
        compare (mat.size (str.read 9)) { rows = 1, columns = 3 } and
        compare str.position 12 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

/*
"interpolated-sine": \(
    // Interpolating a windowed sinusoid should give us a windowed sinusoid
    sinusoid = syn.sinusoid 8 2; // 2Hz sine sampled at 8Hz: [ 0, 1, 0, -1 ] etc
    input = windowedSignalFrom sinusoid 16;
    output = resample.interpolated 2 input;
    result = output.read 32;
    reference = syn.sinusoid 16 2;
    expected = (windowedSignalFrom reference 32).read 32;
    compareMatrices 1e-8 result expected;
),

"decimated-sine": \(
    // Decimating a windowed sinusoid should give us a windowed sinusoid
    sinusoid = syn.sinusoid 32 1; // 1Hz sine sampled at 32Hz
    input = windowedSignalFrom sinusoid 400;
    output = resample.decimated 2 input;
//    result = mat.columnSlice (output.read 200) 50 150;
    result = output.read 200;
    reference = syn.sinusoid 16 1;
//    expected = mat.columnSlice (reference.read 200) 50 150;
    expected = (windowedSignalFrom reference 200).read 200;
    compareMatrices 1e-8 result expected;
),
*/

"resample-spectrum": \(
    // Principle: Generate a wave with a lot of harmonics, resample by
    // some ratio, check that the resulting signal has substantially
    // the same magnitude spectrum as the original.
    
    // Read and window a chunk of signal from a stream
    sigOf str n =
       (sig = mat.getRow 0 (str.read n);
        win.windowed win.hann sig);

    // Return magnitude spectrum, running fft at n points and then
    // truncating to m
    specOf sig n m =
        vec.resizedTo m (bf.divideBy n (fft.realForwardMagnitude n sig));

  //!!! better to generate n separate tests here?

    all id
       (map do inrate: 
        all id
           (map do outrate:
                freq = 500;
                forms = manip.duplicated 2 (waves.square inrate freq);
                inform = forms[0];
                outform = resample.resampledTo outrate forms[1];
                incount = inrate;
                outcount = outrate;
                // We don't compare bins within 1% of the Nyquist freq
                speclen = (min incount outcount) / 2;
                speclen = speclen - int (speclen / 100);
                inmag = specOf (sigOf inform incount) incount speclen;
                outmag = specOf (sigOf outform outcount) outcount speclen;
                compareMatrices 1e-7
                   (mat.newRowVector outmag)
                   (mat.newRowVector inmag);
            done [8000,44100,48000])
        done [8000,44100,48000]);
),

"interpolated-misc": \(
    // Interpolating any signal by N should give a signal in which
    // every Nth sample is the original signal
    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.concat [ data, data ];
    input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
    factor = 3;
    up = resample.interpolated factor input;
    result = mat.getRow 0 (up.read (factor * vec.length data));
    phase = 0;
    b = vec.fromList
       (map do i: vec.at result (i*factor + phase) done [0..vec.length data - 1]);
    compareMatrices 1e-8 (mat.newRowVector b) (mat.newRowVector data);
),

"interpolated-rs-misc": \(
    // Just as above, but using resampledTo instead of interpolated
    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.concat [ data, data ];
    input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
    factor = 3;
    up = resample.resampledTo (factor * input.sampleRate) input;
    result = mat.getRow 0 (up.read (factor * vec.length data));
    phase = 0;
    b = vec.fromList
       (map do i: vec.at result (i*factor + phase) done [0..vec.length data - 1]);
    compareMatrices 1e-8 (mat.newRowVector b) (mat.newRowVector data);
),

/*
"int-dec": \(
    // Interpolating any signal then decimating by the same factor
    // should get us the original back again
    //!!! no, this is phase dependent
//    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
//    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.fromList [ 0, 1, 2, 3 ];
    data = vec.concat [ data, data ];

    factor = 3;

    updown prepad =
       (input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
        intermediate = resample.interpolated factor input;
        output = resample.decimated factor (manip.delayedBy prepad intermediate);
        output.read (vec.length data));

    result = updown 0;
    if not compareMatrices 1e-8 [vec.list (mat.getRow 0 result)] [vec.list data] then
        \() (pl.plot [Vector data, 
                      Vector (mat.getRow 0 result), 
                      Vector (mat.getRow 0 (updown 1)),
                      Vector (mat.getRow 0 (updown 2))]);
        up = (resample.interpolated 2 (syn.precalculatedMono 4 data)).read 80;
        \() (pl.plot [Vector (mat.getRow 0 up)]);

        false
    else true fi;
),
*/
] is hash<string, () -> boolean>;

