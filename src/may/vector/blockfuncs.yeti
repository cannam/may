
module may.vector.blockfuncs;

vec = load may.vector;

{ ceil } = load may.mathmisc;

import may.bits: VectorBits;

sum' v = VectorBits#sum(vec.raw v);

max' v = 
   (dat = vec.raw v;
    var mx = 0;
    for [0..length dat - 1] do i:
        if i == 0 or dat[i] > mx then
            mx := dat[i];
        fi
    done;
    mx);

maxindex v =
   (dat = vec.raw v;
    var mx = 0;
    var mi = -1;
    for [0..length dat - 1] do i:
        if i == 0 or dat[i] > mx then
            mx := dat[i];
            mi := i;
        fi
    done;
    mi);

min' v = 
   (dat = vec.raw v;
    var mn = 0;
    for [0..length dat - 1] do i:
        if i == 0 or dat[i] < mn then
            mn := dat[i];
        fi
    done;
    mn);

minindex v =
   (dat = vec.raw v;
    var mn = 0;
    var mi = -1;
    for [0..length dat - 1] do i:
        if i == 0 or dat[i] < mn then
            mn := dat[i];
            mi := i;
        fi
    done;
    mi);

mean v =
    case vec.length v of
        0: 0;
        len: sum' v / len
    esac;

add bb =
   (len = head (sort (map vec.length bb));
    vv = map vec.raw bb;
    out = new double[len];
    for vv do v:
        VectorBits#addTo(out, v, len);
    done;
    vec.vector out);

subtract b1 b2 =
   (v1 = vec.raw b1;
    v2 = vec.raw b2;
    len = if length v1 < length v2 then length v1 else length v2 fi;
    out = new double[len];
    for [0..len-1] do i:
        out[i] := v1[i] - v2[i]
    done;
    vec.vector out);

multiply b1 b2 = 
    vec.vector VectorBits#multiply(vec.raw b1, vec.raw b2);

scaled n v =
    if n == 1 then v
    else vec.vector VectorBits#scaled(vec.raw v, n);
    fi;

divideBy n v =
    // Not just "scaled (1/n)" -- this way we get exact rationals. In fact
    // the unit test for this function will fail if we use scaled (1/n)
    if n == 1 then v
    else vec.fromList (map (/ n) (vec.list v));
    fi;

sqr v =
    multiply v v;

rms =
    sqrt . mean . sqr;

abs' =
    vec.fromList . (map abs) . vec.list;

negative =
    vec.fromList . (map (0-)) . vec.list;

sqrt' =
    vec.fromList . (map sqrt) . vec.list;

unityNormalised v = 
   (m = max' (abs' v);
    if m != 0 then
        divideBy m v;
    else
        v;
    fi);

fftshift v =
   (len = vec.length v;
    half = int(len/2 + 0.5); // round up for odd-length sequences
    vec.concat [vec.slice v half len, vec.slice v 0 half]);

ifftshift v =
   (len = vec.length v;
    half = int(len/2); // round down for odd-length sequences
    vec.concat [vec.slice v half len, vec.slice v 0 half]);

zipped vv =
    case vv of
    [v]: v;
    first::rest:
       (len = vec.length first;
        if len != min' (vec.fromList (map vec.length vv)) then
            failWith "Vectors must all be of the same length";
        fi;
        vec.fromList
           (concat
              (map do i:
                   map do v:
                       vec.at v i
                       done vv
                   done [0..len-1])));
     _: vec.zeros 0;
    esac;

unzipped n v =
    if n == 1 then array [v]
    else 
        len = vec.length v;
        vv = array (map \(new double[ceil(len / n)]) [1..n]);
        for [0..len-1] do x:
            vv[x % n][int (x / n)] := vec.at v x;
        done;
        array (map vec.vector vv);
    fi;

{
sum is vec.vector_t -> number = sum',
mean is vec.vector_t -> number,
add is list?<vec.vector_t> -> vec.vector_t,
subtract is vec.vector_t -> vec.vector_t -> vec.vector_t,
multiply is vec.vector_t -> vec.vector_t -> vec.vector_t, 
divideBy is number -> vec.vector_t -> vec.vector_t, 
scaled is number -> vec.vector_t -> vec.vector_t,
abs is vec.vector_t -> vec.vector_t = abs',
negative is vec.vector_t -> vec.vector_t,
sqr is vec.vector_t -> vec.vector_t,
sqrt is vec.vector_t -> vec.vector_t = sqrt',
rms is vec.vector_t -> number,
max is vec.vector_t -> number = max',
min is vec.vector_t -> number = min',
maxindex is vec.vector_t -> number,
minindex is vec.vector_t -> number,
unityNormalised is vec.vector_t -> vec.vector_t,
fftshift is vec.vector_t -> vec.vector_t,
ifftshift is vec.vector_t -> vec.vector_t,
zipped is list?<vec.vector_t> -> vec.vector_t,
unzipped is number -> vec.vector_t -> array<vec.vector_t>,
}


        
