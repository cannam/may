module test.test_vamppost;

vp = load vamppost;

{ compare } = load test.test;

untimed n = { timestamp = Untimed (), values = [n] };
timed t n = { timestamp = Time t, values = [n] };

[

"fillOneSamplePerStep": \(
    filled = vp.fillTimestamps {
        output = { sampleType = OneSamplePerStep () },
        config = { sampleRate = 1000, stepSize = 100 },
        features = [
            [],
            [ untimed 1 ],
            [ untimed 1, untimed 2 ],
            [],
            [ timed 1 1, untimed 2, timed 4 3 ]
        ]
    };
    compare filled [
        timed 0.1 1 ,
        timed 0.2 1, timed 0.2 2 ,
        timed 0.4 1, timed 0.4 2, timed 0.4 3
    ];
),

"fillFixedSampleRate": \(
    // "If the output feature's hasTimestamp field is true, the host
    // should read and use the output feature's timestamp [...] If
    // [hasTimestamp] is false, its time will be implicitly calculated
    // by incrementing the time of the previous feature according to
    // the [output descriptor's] sample rate"
    filled = vp.fillTimestamps {
        output = { sampleType = FixedSampleRate 500 },
        config = { sampleRate = 1000, stepSize = 100 },
        features = [
            [],
            [ untimed 1 ],
            [ untimed 1, untimed 2 ],
            [],
            [ timed 1 1, untimed 2, timed 4 3 ]
        ]
    };
    compare filled [
        timed 0 1 ,
        timed 0.2 1, timed 0.4 2 ,
        timed 1.0 1, timed 1.2 2, timed 4.0 3
    ];
),

"fillVariableSampleRate": \(
    // For VariableSampleRate outputs, the timestamps should always
    // be left entirely alone by fillTimestamps -- it's an error for
    // the plugin to return any features without valid timestamps,
    // but it isn't the job of fillTimestamps to handle that error
    filled = vp.fillTimestamps {
        output = { sampleType = VariableSampleRate 500 },
        config = { sampleRate = 1000, stepSize = 100 },
        features = [
            [],
            [ untimed 1 ],
            [ untimed 1, untimed 2 ],
            [],
            [ timed 1 1, untimed 2, timed 4 3 ]
        ]
    };
    compare filled [
        untimed 1 ,
        untimed 1, untimed 2 ,
        timed 1.0 1, untimed 2, timed 4.0 3
    ];
),

] is hash<string, () -> boolean>;

