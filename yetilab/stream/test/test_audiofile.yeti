
module yetilab.stream.test.test_audiofile;

af = load yetilab.stream.audiofile;
vec = load yetilab.vector.vector;
mat = load yetilab.matrix.matrix;
bf = load yetilab.vector.blockfuncs;
pl = load yetilab.plot.plot;

ref = load yetilab.stream.test.audiofile_reference;

{ compare, compareUsing } = load yetilab.test.test;

testfile name = "yetilab/test/data/\(name).wav";

float n is number -> number =
    // round number to float precision (for comparison with floats)
   (arr = new float[1];
    arr[0] := n;
    arr[0]);

readAll stream =
    case stream.available of
    Known n: stream.read n;
    _: failWith "Known-duration stream required";
    esac;

bitdepthComparator depth =
   (range = fold do a _: a*2 done 1 [1..depth]; // 2^depth
    unsigned = (range == 8);
    // Although for float->int conversion on writing we multiply by
    // max-1 (e.g. by 32767 in 16-bit signed export), when reading we
    // divide by 32768 -- in both cases trying to avoid overflow.  For
    // this comparison we get a test sample (read from a file) and a
    // reference sample (synthesised locally) and we need to simulate
    // the export process for the synthetic one while inverting the
    // import process for the test sample.
    do test ref:
        test' = round
            if unsigned then (test + 1) * range
            else test * (range/2)
            fi;
        ref' = round
            if unsigned then (ref * (range-1)) - (range/2)
            else ref * (range/2 - 1)
            fi;
        if abs(test' - ref') <= 1 then true
        else 
            eprintln "bitdepthComparator: \(test) != \(ref) at bitdepth \(depth) [\(test') != \(ref')]";
            false;
        fi;
    done);

maxOf m =
    bf.max (vec.fromList (map bf.max (mat.asRows m)));

testReferenceFile rate channels bitdepth =
   (test = readAll (af.open (testfile "\(rate)-\(channels)-\(bitdepth)"));
    ref = readAll (ref.afReference rate channels);
    if mat.equalUnder (bitdepthComparator bitdepth) test ref then
        true
    else
        println "** peak difference: \(maxOf (mat.difference ref test))";
        for [0..mat.height test - 1] do ch:
            if mat.equalUnder (bitdepthComparator bitdepth)
               (mat.newRowVector (mat.getRow ch test))
               (mat.newRowVector (mat.getRow ch ref)) then
                println "   channel \(ch): ok";
            else
                println "   channel \(ch): not ok";
// This isn't really simple enough!
/*!!!
                seriesFor m =
                    Series {
                        start = 0, 
                        step = 1, 
                        values = take 1000 (vec.list (mat.getRow ch m))
                        };
                \() (pl.plot (map seriesFor [ test, ref, mat.scaled 10000 (mat.difference test ref) ]));
*/
            fi;
        done;
        false
    fi);

[ 

"20samples-open": \(
    f = af.open (testfile "20samples");
    compare f.position 0 and
        compare f.channels 1 and
        compare f.sampleRate 44100 and
        compare f.available (Known 20) and
        compare f.finished? false and
        ( f.close () ; true )
),

"20samples-read": \(
    all id (map do opener:
        f = opener (testfile "20samples");
        first15 = f.read 15;
        last5 = f.read 10;
        compare (mat.size first15) { rows = 1, columns = 15 } and
            compare (mat.size last5) { rows = 1, columns = 5 } and
            compare (vec.list (mat.getRow 0 first15))
                [ float (32767/32768),0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] and
            compare (vec.list (mat.getRow 0 last5)) [ 0,0,0,0,-1 ] and
            ( f.close () ; true )
        done [ af.open, af.openMono ]);
),

"8000-1-8": \(
    testReferenceFile 8000 1 8;
),

"44100-2-16": \(
    testReferenceFile 44100 2 16;
),

] is hash<string, () -> boolean>

