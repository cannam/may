
module yetilab.stream.channels;

vec = load yetilab.block.fvector;
block = load yetilab.block.block;
mat = load yetilab.matrix.matrix;
        
interleaved m = 
   ({ columns, rows } = m.size;
    v = vec.zeros (columns * rows);
    for [0..rows-1] do row:
        for [0..columns-1] do col:
            v[col * rows + row] := m.getAt row col;
        done;
    done;
    block.block v);

deinterleaved channels b = //!!! should generate a RowMajor matrix for faster framing
   (v = block.data b;
    mat.generate do row col:
        v[channels * col + row]
    done { rows = channels, columns = ((vec.length v) / channels) });

mixedDown m =
   ({ columns, rows } = m.size;
    v = vec.zeros columns;
    for [0..rows-1] do row:
        for [0..columns-1] do col:
            v[col] := v[col] + m.getAt row col;
        done;
    done;
    block.block v);

mixedDownFromInterleaved channels b =
   (v = block.data b;
    columns = ((vec.length v) / channels);
    v' = vec.zeros columns;
    for [0..channels-1] do row:
        for [0..columns-1] do col:
            v'[col] := v'[col] + v[col * channels + row];
        done;
    done;
    block.block v');

mixedFromInterleavedTo targetChannels channels b = 
    if targetChannels == channels then
        b;
    elif targetChannels == 1 then
        mixedDownFromInterleaved channels b;
    else
        v = block.data b;
        columns = ((vec.length v) / channels);
        v' = vec.zeros (columns * targetChannels);
        for [0..targetChannels-1] do target:
            for [0..columns-1] do col:
                if target < channels then
                    v'[col * targetChannels + target] := v[col * channels + target];
                elif channels == 1 then
                    v'[col * targetChannels + target] := v[col * channels];
                fi
            done
        done;
        block.block v';
    fi;

mixedAndInterleavedTo targetChannels m = 
    if targetChannels == 1 then
        mixedDown m
    else
        interleaved
           (mat.resizedTo { rows = targetChannels, columns = m.size.columns } m)
    fi;

{
    interleaved, deinterleaved,
    mixedDown, mixedDownFromInterleaved, mixedFromInterleavedTo, mixedAndInterleavedTo
}

