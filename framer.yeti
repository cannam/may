
module framer;

vec = load fvector;
block = load block;
af = load audiofile;

blockList blocksize stream =
    if stream.finished? then
       (stream.close (); [] );
    else
        block.resizedTo blocksize (stream.readMono blocksize)
            :. \(blockList blocksize stream);
    fi;

overlappingBlockList bs hop stream valid buffer
    is number -> number -> 'a -> number -> ~double[] -> 'b =
   (b = stream.readMono hop;
    obtained = block.length b;
    samples = block.unblock b;

    // Shift existing buffer down by hop
    for [hop..bs-1] do i: buffer[i-hop] := buffer[i] done;

    // Copy hop new elements in from samples (and extra zeros if needed)
    for [0..obtained-1] do i: buffer[bs-hop+i] := samples[i] done;
    for [obtained..hop-1] do i: buffer[bs-hop+i] := 0.0 done;

    // Number of "valid" elements (not tail-end zero-padding) left in buffer
    remaining = valid - (hop - obtained);

    if remaining <= 0 then
        stream.close ();
        [];
    else
        // Copy buffer to return
        v = block.block (vec.copyOf buffer);
        v :. \(overlappingBlockList bs hop stream remaining buffer);
    fi);

frames blocksize stream =
    blockList blocksize stream;

framesOfFile blocksize filename =
    blockList blocksize (af.open filename);

overlappingFrames { blocksize, hop } stream =
    overlappingBlockList blocksize hop stream blocksize (vec.zeros blocksize);

overlappingFramesOfFile { blocksize, hop } filename =
    overlappingBlockList blocksize hop (af.open filename)
        blocksize (vec.zeros blocksize);

{ 
    frames, overlappingFrames,
    framesOfFile, overlappingFramesOfFile,
}

