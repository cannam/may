module vamp;

import org.vamp_plugins:
       Plugin, Plugin$InputDomain,
       PluginLoader, PluginLoader$AdapterFlags,
       ParameterDescriptor, OutputDescriptor,
       RealTime, Feature;

import java.lang: UnsatisfiedLinkError;

import java.util: TreeMap, AbstractList;

block = load block;
fr = load framer;
af = load audiofile;

listPlugins () =
   (try
        map string PluginLoader#getInstance()#listPlugins();
    catch UnsatisfiedLinkError e:
        eprintln "Warning: Unable to obtain plugin list:\n\(e)";
        [];
    yrt);
   
categoryOf key =
    list PluginLoader#getInstance()#getPluginCategory(key);

parameterDescriptor pd is ~ParameterDescriptor -> 'a = {
    identifier = pd#identifier,
    name = pd#name,
    description = pd#description,
    unit = pd#unit,
    minValue = pd#minValue,
    maxValue = pd#maxValue,
    defaultValue = pd#defaultValue,
    isQuantized = pd#isQuantized,
    quantizeStep = pd#quantizeStep,
    valueNames = map string pd#valueNames
    };

outputDescriptor od is ~OutputDescriptor -> 'a = {
    identifier = od#identifier,
    name = od#name,
    description = od#description,
    unit = od#unit,
    hasFixedBinCount = od#hasFixedBinCount,
    binCount = od#binCount,
    binNames = map string od#binNames,
    hasKnownExtents = od#hasKnownExtents,
    minValue = od#minValue,
    maxValue = od#maxValue,
    isQuantized = od#isQuantized,
    quantizeStep = od#quantizeStep,
    sampleType = od#sampleType,
    sampleRate = od#sampleRate,
    hasDuration = od#hasDuration,
    };

plugin key p is string -> ~Plugin -> 'a = {
    plugin = p,
    key,
    get apiVersion () = p#getVampApiVersion(),
    get identifier () = p#getIdentifier(),
    get name () = p#getName(),
    get description () = p#getDescription(),
    get maker () = p#getMaker(),
    get copyright () = p#getCopyright(),
    get version () = p#getPluginVersion(),
    get category () = PluginLoader#getInstance()#getPluginCategory(key),
    get parameters () = map parameterDescriptor p#getParameterDescriptors(),
    parameter identifier = p#getParameter(identifier),
    setParameter identifier value = p#setParameter(identifier, value),
    get programs () = map string p#getPrograms(),
    get currentProgram () = p#getCurrentProgram(),
    selectProgram pr = p#selectProgram(pr),
    get inputDomain () = p#getInputDomain(),
    get preferredBlockSize () = p#getPreferredBlockSize(),
    get preferredStepSize () = p#getPreferredStepSize(),
    get minChannelCount () = p#getMinChannelCount(),
    get maxChannelCount () = p#getMaxChannelCount(),
    initialise channels blocksize hop = p#initialise(channels, blocksize, hop),
    reset () = p#reset(),
    get outputs () = map outputDescriptor p#getOutputDescriptors(),
    process floats time is ~float[][] -> ~RealTime -> 'a = p#process(floats, 0, time),
    dispose () = p#dispose(),
    };

realTime r is ~RealTime -> number = r#sec() + (r#nsec() / 1000000000);

feature f is ~Feature -> 'a = {
    get timestamp () = if f#hasTimestamp then Time (realTime f#timestamp) else Untimed () fi,
    get duration () = if f#hasDuration then Time (realTime f#duration) else Untimed () fi,
    get values () = list f#values,
    get label () = f#label,
    };

featureList fl is ~Object -> 'a =
    if nullptr? fl then []
    else
        a = fl unsafely_as ~AbstractList;
        result = array [];
        itr = a#iterator();
        itr#hasNext() loop (push result (feature (itr#next() unsafely_as ~Feature)));
        list result
    fi;

featuresFromSet outputNo f is number -> ~TreeMap -> 'a =
    featureList (f#get(outputNo as ~Integer));

converted outputNo fl is number -> list?<~TreeMap> -> 'a =
    map (featuresFromSet outputNo) fl;

outputNumberByName p name =
   (outputs = p.outputs;
    index (head (find ((== name) . (.identifier)) outputs)) outputs);

loadPlugin rate key =
    plugin key PluginLoader#getInstance()#loadPlugin(key, rate, PluginLoader$AdapterFlags#ADAPT_INPUT_DOMAIN + PluginLoader$AdapterFlags#ADAPT_CHANNEL_COUNT);

processed { p, sampleRate, hop } frames count =
    case frames of
        this::rest:
            p.process
                ([block.floats this] as ~float[][])
                RealTime#frame2RealTime(count, sampleRate)
            :.
            \(processed { p, sampleRate, hop } rest (count + hop));
        _: 
           (p.dispose ();
            []);
    esac;

process key output stream =
   (p = loadPlugin stream.sampleRate key;
    blockSize = p.preferredBlockSize;
    hop = p.preferredStepSize;
    outputNo = outputNumberByName p output;
    if p.initialise 1 blockSize hop then
        converted outputNo
           (processed
            { p, sampleRate = stream.sampleRate, hop } 
            (fr.frames { framesize = blockSize, hop } stream)
            0);
    else
        p.dispose();
        stream.close();
        [];
    fi);

processFile key output filename = process key output (af.open filename);

{
get pluginKeys = listPlugins,
loadPlugin,
categoryOf,
process,
processFile,
}

