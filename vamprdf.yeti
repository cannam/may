
module vamprdf;

vamp = load vamp;

read = load yertle.read;
{ newRdfStore } = load yertle.store;

import java.io: File;

listVampRdfFiles () =
    concat
       (map do p:
            map ((p ^ File#separator ^) . (.name))
               (filter do entry:
                    entry.file? and
                       (lc = strLower entry.name;
                        (strEnds? lc ".ttl") or
                        (strEnds? lc ".n3") or
                        (strEnds? lc ".nt"))
                    done (listDirectory false p))
            done (vamp.pluginPath));

loadVampRdfStore store =
    for (listVampRdfFiles ()) do file:
        case read.loadTurtleFile store ("file://" ^ file) file of
        OK (): ();
        Error e: eprintln
            "WARNING: Failed to load Vamp plugin RDF file \"\(file)\": \(e)";
        esac
    done;

addVampPrefixes store =
   (store.addPrefix "vamp" "http://purl.org/ontology/vamp/";
    store.addPrefix "dc" "http://purl.org/dc/elements/1.1/";
    store.addPrefix "foaf" "http://xmlns.com/foaf/0.1/";
    store.addPrefix "owl" "http://www.w3.org/2002/07/owl#");

store = newRdfStore ();
var loaded = false;

getSystemVampRdfStore () =
    synchronized store do:
        if not loaded then
            addVampPrefixes store;
            loadVampRdfStore store;
            loaded := true;
        fi;
        store
    done;

getGlobalPluginIndex () =
    list (strSplit "\n" (fetchURL [ Timeout 10 ] (Handle getContents)
                         "http://www.vamp-plugins.org/rdf/plugins/index.txt"));

//!!! need to cache these retrievals
parseGlobalVampRdf () =
   (parse urls =
        case urls of
        url::rest:
           (doc = fetchURL [ Timeout 10 ] (Handle getContents) url;
            parsed = read.parseTurtleString url doc;
            { url, parsed } :. \(parse rest));
         _: [];
        esac;
    parse (getGlobalPluginIndex ()));

loadGlobalVampRdf store =
    for (parseGlobalVampRdf ()) do { url, parsed }:
        case read.loadParsedTriples store parsed of
        OK (): ();
        Error e: eprintln "WARNING: Failed to load Vamp RDF from URL \(url): \(e)";
        esac;
    done;

filterIRIsFromNodes nodes =
    map do r: case r of IRI iri: iri; esac done
       (filter do r: case r of IRI iri: true; _: false esac done nodes);

subjects = map (.s);

iriTypes = map do t: case t of IRI iri: IRI iri; Blank n: Blank n esac done;

iriSubjects = iriTypes . subjects;

libraryNodes store =
    iriSubjects
       (store.match {
            s = Wildcard (),
            p = Known (store.expand "a"),
            o = Known (store.expand "vamp:PluginLibrary")
            });

pluginNodes store =
    iriSubjects
       (store.match {
            s = Wildcard (),
            p = Known (store.expand "a"),
            o = Known (store.expand "vamp:Plugin")
            });

pluginsWithId store id = 
    iriTypes
       (filter do pnode:
        store.contains {
            s = pnode,
            p = store.expand "vamp:identifier",
            o = Literal { value = id, type = "", language = "" }
            }
        done (pluginNodes store));

librariesWithId store id =
    iriTypes
       (filter do lnode:
        store.contains {
            s = lnode,
            p = store.expand "vamp:identifier",
            o = Literal { value = id, type = "", language = "" }
            }
        done (libraryNodes store));

pluginNodesById store libraryId pluginId =
   (candidatePlugins = pluginsWithId store pluginId;
    candidateLibraries = librariesWithId store libraryId;
    filter do pnode:
        any do lnode:
            store.contains {
                s = lnode,
                p = store.expand "vamp:available_plugin",
                o = pnode
                }
            done candidateLibraries
        done candidatePlugins
    );

textProperty store subject name =
    case store.match {
        s = Known subject, p = Known (store.expand name), o = Wildcard ()
        } of
        { o = Literal { value = text } }::others: text;
         _: "";
    esac;

inputDomainOf store pluginIRI =
   case store.match {
        s = Known pluginIRI, p = Known (store.expand "vamp:input_domain"), o = Wildcard ()
        } of
        { o = IRI iri }::others:
            if IRI iri == store.expand "vamp:FrequencyDomain"
            then FrequencyDomain ()
            else TimeDomain ()
            fi;
         _: TimeDomain ();
    esac;

getPluginData store pluginIRI = {
    get apiVersion () = textProperty store pluginIRI "vamp:vamp_API_version", //!!! number not text
    get identifier () = textProperty store pluginIRI "vamp:identifier",
    get name () = textProperty store pluginIRI "dc:title",
    get description () = textProperty store pluginIRI "dc:description",
    get maker () = textProperty store pluginIRI "foaf:maker", //!!! is an IRI or blank node
    get copyright () = textProperty store pluginIRI "dc:rights",
    get version () = textProperty store pluginIRI "owl:versionInfo",
    get category () = textProperty store pluginIRI "vamp:category",
    get inputDomain () = inputDomainOf store pluginIRI
};

//!!! reconsider these names
{
getGlobalPluginIndex,
parseGlobalVampRdf,
loadGlobalVampRdf,
getSystemVampRdfStore,
vampPluginNodes = pluginNodes,
vampLibraryNodes = libraryNodes,
vampPluginNodesById = pluginNodesById,
vampPluginData = getPluginData,
}

