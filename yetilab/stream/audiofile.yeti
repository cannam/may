
module yetilab.stream.audiofile;

import javax.sound.sampled:
     AudioSystem, AudioInputStream, AudioFormat, AudioFormat$Encoding,
     UnsupportedAudioFileException;

import java.io: File, IOException;

import java.nio: ByteBuffer, ByteOrder;

str = load yetilab.stream.stream;
ch = load yetilab.stream.channels;
block = load yetilab.block.block;

decode8u bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (for [0..n-1] do i:
       doubles[i] := (bytes[i] / 128.0) - 1.0;
    done
   );

decode16s bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (bb = ByteBuffer#wrap(bytes, 0, n * 2);
    bb#order(ByteOrder#LITTLE_ENDIAN);
    for [0..n-1] do i:
       doubles[i] := bb#getShort(i*2) / 32768.0;
    done
   );

decode32f bytes doubles n is ~byte[] -> ~double[] -> number -> () =
   (bb = ByteBuffer#wrap(bytes, 0, n * 4);
    bb#order(ByteOrder#LITTLE_ENDIAN);
    for [0..n-1] do i:
       doubles[i] := bb#getFloat(i*4);
    done
   );

decodeFail () = 
    throw new UnsupportedAudioFileException("File format not supported. Supported formats are 8-bit unsigned PCM, 16-bit signed little-endian PCM, or IEEE float");

decode { format is ~AudioFormat } bytes doubles n = 
   (if format#isBigEndian() then
        decodeFail()
    else
        enc = format#getEncoding();
        bits = format#getSampleSizeInBits();
        if bits == 32 then
            decode32f bytes doubles n;
        elif bits == 16 and enc == AudioFormat$Encoding#PCM_SIGNED then
            decode16s bytes doubles n;
        elif bits == 8 and enc == AudioFormat$Encoding#PCM_UNSIGNED then
            decode8u bytes doubles n;
        else
            decodeFail();
        fi
    fi);

readInterleaved' { format is ~AudioFormat, stream is ~AudioInputStream } nframes =
   (channels = format#getChannels();
    bytesPerSample = format#getSampleSizeInBits() / 8;
    bytes = new byte[nframes * channels * bytesPerSample];
    bytesRead = stream#read(bytes);
    if bytesRead <= 0 then block.zeros 0;
    else
        n = int(bytesRead / bytesPerSample);
        doubles = new double[n];
        decode { format } bytes doubles n;
        block.block doubles;
    fi;
   );

read' { format is ~AudioFormat, stream is ~AudioInputStream } n =
   (b = readInterleaved' { format, stream } n;
    channels = format#getChannels();
    ch.deinterleaved channels b;
   );

readMono' { format is ~AudioFormat, stream is ~AudioInputStream } n =
   (b = readInterleaved' { format, stream } n;
    channels = format#getChannels();
    ch.mixedDownFromInterleaved channels b;
   );

// Note, all this assumes the stream is non-blocking (i.e. available()
// is to the end of file)

available' { format is ~AudioFormat, stream is ~AudioInputStream } =
    stream#available() / ((format#getSampleSizeInBits() / 8) * format#getChannels());

close' { stream is ~AudioInputStream } =
    stream#close();

open name is string -> 'a = 
   (f = new File(name);
    stream = AudioSystem#getAudioInputStream(f);
    format = stream#getFormat();
    len = available' { format, stream }; // at start of stream
    str.stream {
        stream,
        format,
        len,
        rate = format#getSampleRate(),
        channels = format#getChannels(),
        get position () = len - available' { stream, format },
        get available () = available' { stream, format },
        read = read' { stream, format },
        readInterleaved = readInterleaved' { stream, format },
        readMono = readMono' { stream, format },
        close () = close' { stream },
    });

{
    open
}

