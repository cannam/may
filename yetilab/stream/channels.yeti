
module yetilab.stream.channels;

vec = load yetilab.block.fvector;
block = load yetilab.block.block;
mat = load yetilab.matrix.matrix;
        
interleaved m = 
   ({ columns, rows } = m.size;
    if rows == 1 then
        m.getRow 0
    else
        v = vec.zeros (columns * rows);
        for [0..rows-1] do row:
            for [0..columns-1] do col:
                v[col * rows + row] := m.getAt row col;
            done;
        done;
        block.block v;
    fi);

deinterleaved channels b =
    if channels == 1 then
        mat.newRowVector b
    else
        rows = (block.length b) / channels;
        vv = array (map \(vec.zeros rows) [0..channels-1]);
        v = block.data b;
        for [0..rows-1] do row:
            for [0..channels-1] do col:
                vv[col][row] := v[channels * row + col];
            done
        done;
        mat.newMatrix (RowMajor ()) (map block.block vv);
    fi;

mixedDown m =  //!!! sum or average? at the moment we sum
   ({ columns, rows } = m.size;
    v = vec.zeros columns;
    for [0..rows-1] do row:
        for [0..columns-1] do col:
            v[col] := v[col] + m.getAt row col;
        done;
    done;
    block.block v);

mixedDownFromInterleaved channels b =
    if channels == 1 then
        b;
    else
        v = block.data b;
        columns = ((vec.length v) / channels);
        v' = vec.zeros columns;
        for [0..channels-1] do row:
            for [0..columns-1] do col:
                v'[col] := v'[col] + v[col * channels + row];
            done;
        done;
        block.block v';
    fi;

mixedFromInterleavedTo targetChannels channels b = 
    if targetChannels == channels then
        b;
    elif targetChannels == 1 then
        mixedDownFromInterleaved channels b;
    else
        v = block.data b;
        columns = ((vec.length v) / channels);
        v' = vec.zeros (columns * targetChannels);
        for [0..targetChannels-1] do target:
            for [0..columns-1] do col:
                if target < channels then
                    v'[col * targetChannels + target] := v[col * channels + target];
                elif channels == 1 and target == 1 then
                    v'[col * targetChannels + target] := v[col * channels];
                fi
            done
        done;
        block.block v';
    fi;

mixedTo targetChannels m = 
    if targetChannels == m.size.rows then    // n -> n: pass unmodified
        m
    elif targetChannels == 1 then            // n -> 1: mix down
        deinterleaved 1 (mixedDown m)
    elif m.size.rows == 1 then               // 1 -> n: copy to all channels
        mat.newMatrix (RowMajor ()) (map \(m.getRow 0) [1..targetChannels])
    else                                     // n -> m: truncate or add zeros
        mat.resizedTo { rows = targetChannels, columns = m.size.columns } m
    fi;

mixedAndInterleavedTo targetChannels m = 
    if targetChannels == 1 then
        mixedDown m
    else
        interleaved (mixedTo targetChannels m);
    fi;

//!!! some of these names are terrible
{
    interleaved, deinterleaved,
    mixedDown, mixedDownFromInterleaved,
    mixedFromInterleavedTo, mixedTo, mixedAndInterleavedTo
}

