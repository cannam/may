
module fft;

import edu.emory.mathcs.jtransforms.fft: DoubleFFT_1D;

b = load block;
vec = load fvector;
complex = load complex;

packedToComplex p =
   (n = (vec.length p) / 2;
    array
       (map do i:
            re = if i == n then p[1] else p[i*2] fi;
            im = if i == 0 or i == n then 0 else p[i*2+1] fi;
            complex.complex re im;
        done [0..n]));

complexToPacked arr =
   (n = length arr;
    v = vec.vector
       (map do i:
            ix = int (i/2);
            if i == ix*2 then
                complex.real arr[ix]
            else 
                complex.imaginary arr[ix] 
            fi;
            done [0..(n-1)*2-1]);
    v[1] := complex.real arr[n-1];
    v);

realForward n = 
   (d = new DoubleFFT_1D(n);
    do bl:
        v = b.vector bl;
        d#realForward(v);
        packedToComplex v;
    done);

realInverse n = 
   (d = new DoubleFFT_1D(n);
    do arr:
        v = complexToPacked arr;
        d#realInverse(v, true);
        b.block v;
    done);

{
realForward,
realInverse,
}

