module floatrix;

zeros n = new double[n];
ones  n = (a = zeros n; for [0..n-1] do i: a[i] := 1.0 done; a);

vector l is list?<number> -> ~double[] =
   (arr = array(l);
    len = length arr;
    v = new double[len];
    for [0..len-1] do i: n = arr[i]; v[i] := n done;
    v);

zeroMatrix rows cols = array (map \(zeros cols) [1..rows]);

generateMatrix f rows cols =
   (m = zeroMatrix rows cols;
    for [0..rows-1] do row:
        for [0..cols-1] do col:
            n = f row col;
            m[row][col] := n;
        done;
    done;
    m);

constMatrix n = generateMatrix do row col: n done;

randomMatrix = generateMatrix do row col: Math#random() done;

identityMatrix = constMatrix 1;

arrayWrap a is ~double[] -> array<number> = array(a);

width m = if length m > 0 then length (arrayWrap m[0]) else 0 fi;

cols = width;

height m = length m;

rows = height;

dimensions m = { cols = width m, rows = height m };

transposed m is array<~double[]> -> array<~double[]> = 
    generateMatrix do row col: m[col][row] done (cols m) (rows m);
        
interleaved m = 
   ({ cols, rows } = dimensions m;
    v = zeros (cols * rows);
    for [0..rows-1] do row:
        for [0..cols-1] do col:
            v[col * rows + row] := m[row][col];
        done;
    done;
    v);

deinterleaved rows v is number -> ~double[] -> array<~double[]> =
    generateMatrix do row col:
        v[rows * col + row]
    done rows (length (arrayWrap v) / rows);

    //!!! too inefficient!
mixedDown rows v is number -> ~double[] -> ~double[] =
   (cols = (length (arrayWrap v) / rows);
    mv = new double[cols];
    for [0..cols-1] do col:
        val = sum (map do row: v[col * rows + row] done [0..rows-1]) / rows;
        mv[col] := val;
    done;
    mv);

{
zeros, ones, vector,
generateMatrix, constMatrix, randomMatrix, zeroMatrix, identityMatrix,
width, cols, height, rows, dimensions,
transposed, interleaved, deinterleaved,
mixedDown,
}

