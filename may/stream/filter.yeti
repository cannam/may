
module may.stream.filter;

mat = load may.matrix;
ch = load may.stream.channels;
vec = load may.vector;
bf = load may.vector.blockfuncs;
fr = load may.stream.framer;
win = load may.signal.window;
fft = load may.transform.fft;
syn = load may.stream.syntheticstream;
cplx = load may.complex;

load may.stream.type;
load may.vector.type;
load may.matrix.type;

//!!! todo: synchronized for everything with state assignment

minDurationOf d1 d2 =
    case d1 of 
    Known a:
        case d2 of 
        Known b: Known (min a b);
        Unknown (): Unknown ();
        Infinite (): Known a;
        esac;
    Unknown ():
        case d2 of 
        Known b: Known b;
        Unknown (): Unknown ();
        Infinite (): Unknown ();
        esac;
    Infinite ():
        d2;
    esac;

withDuration nsamples s = //!!! should nsamples be a time in seconds? (no)
   (var pos = 0;
    s with
    {
        get position () = pos,
        get available () = Known (nsamples - pos),
        get finished? () = not (nsamples > pos),
        read count =
           (n = min count (nsamples - pos);
            pos := pos + n;
            if not s.finished? then
                mat.resizedTo { rows = s.channels, columns = n } (s.read n);
            else 
                mat.zeroMatrix { columns = n, rows = s.channels }
            fi),
    });

delayedBy nsamples s = //!!! doc: nsamples may be -ve
   (var prepos = 0;
    zeros n = mat.toRowMajor
       (prepos := prepos + n;
        mat.zeroMatrix { rows = s.channels, columns = n });
    delay = 
        if nsamples < 0 then
            \0 (s.read (-nsamples));
        else
            nsamples
        fi;
    {
        get position () = 
            if prepos < delay then prepos
            elif s.position + nsamples < 0 then 0
            else s.position + nsamples
            fi,
        get channels () = s.channels,
        get sampleRate () = s.sampleRate,
        get available () = 
            case s.available of 
            Known a: Known (a + delay - prepos); 
            other: other 
            esac,
        get finished? () = (prepos >= delay) and s.finished?,
        read count =
            if prepos >= delay then s.read count
            elif prepos + count < delay then zeros count
            else
                nleft = delay - prepos;
                left = zeros nleft;
                right = s.read (count - nleft);
                mat.concat (Horizontal ()) [left, right];
            fi,
        close = s.close
    });

scaledBy factor s =
    s with
    {
        read count = mat.scaled factor (s.read count);
    };

inverted s = //!!! todo: test
    s with
    {
        read count = 
           (m = s.read count;
            if mat.empty? m then m
            else mat.difference (mat.zeroMatrix (mat.size m)) m
            fi)
    };

//!!! poor name, confusion with mixed, but consistent with channels.yeti
mixedTo targetChannels s =
    s with
    {
        get channels () = targetChannels,
        read count = ch.mixedTo targetChannels (s.read count),
    };

//!!! what should happen if we mix or multiplex a finite-length and an
//infinite-length stream? or even two streams with differing finite
//lengths? write tests for this. At the moment the resulting stream
//has duration equal to the shortest source stream and finishes as
//soon as any one of them finishes

sum' streams =
   (mix m1 m2 =
       (sz = { rows = max (mat.height m1) (mat.height m2),
               columns = min (mat.width m1) (mat.width m2) };
        if sz.columns == 0 then
            mat.zeroSizeMatrix ()
        else
            mat.sum (mat.resizedTo sz m1) (mat.resizedTo sz m2);
        fi);
    {
        get position () = head (sort (map (.position) streams)),
        get channels () = head (sortBy (>) (map (.channels) streams)),
        get sampleRate () = (head streams).sampleRate, //!!! document this
        get available () =
            fold do dur s: minDurationOf dur s.available done (Infinite ()) streams,
        get finished? () = any id (map (.finished?) streams),
        read count =
           (readTo acc ss count =
               case ss of
               first::rest:
                   part = first.read count;
                   case acc of 
                   Some m:
                       readTo (Some (mix m part)) rest count;
                   None ():
                       readTo (Some part) rest count;
                   esac;
                _: acc;
               esac;
            case readTo (None ()) streams count of
            None (): mat.zeroSizeMatrix ();
            Some m: m;
            esac),
        close () = for streams do s: s.close() done,
    });

mean streams = //!!! todo: test
    scaledBy (1 / (length streams)) (sum' streams);

difference s1 s2 = //!!! todo: test
    sum' [ s1, inverted s2 ];

multiplexed streams = 
    {
        get position () = head (sort (map (.position) streams)), // can differ after EOS
        get channels () = sum (map (.channels) streams),
        get sampleRate () = (head streams).sampleRate, //!!! document this
        get available () = 
            fold do dur s: minDurationOf dur s.available done (Infinite ()) streams,
        get finished? () = any id (map (.finished?) streams),
        read count =
           (outs = map do s: s.read count done streams;
            minlen = head (sort (map mat.width outs));
            outs = map do m:
                mat.resizedTo { rows = mat.height m, columns = minlen } m
                done outs;
            mat.concat (Vertical ()) outs
            ),
        close () = for streams do s: s.close() done,
    };

repeated s =
    // There is no way to reset a stream (as in principle, they might
    // be "live") so we can't read from the same stream repeatedly --
    // we have to cache its output and then repeat that. This is a
    // little tricky to do efficiently without knowing how long the
    // stream is (in general) or how much is going to be requested at
    // a time.
    if s.available == Infinite () then s
    else
        var pos = 0;
        var cache = mat.zeroSizeMatrix ();
        chunks = array [];
        cachedPartsFor count =
           (start = pos % (mat.width cache);
            avail = (mat.width cache) - start;
            if avail >= count then
                pos := pos + count;
                [mat.columnSlice cache start (start + count)]
            else
                pos := pos + avail;
                mat.columnSlice cache start (start + avail) ::
                    cachedPartsFor (count - avail);
            fi);
        readFromCache count =
           (if (mat.width cache) == 0 then
                cache := mat.concat (Horizontal ()) (list chunks);
                clearArray chunks;
            fi;
            if (mat.width cache) == 0 then
                cache
            else
                mat.concat (Horizontal ()) (cachedPartsFor count);
            fi);
        s with
        {
            get position () = pos,
            get available () = Infinite (),
            get finished? () = false,
            read count =
                if s.finished? then
                    readFromCache count
                else
                    part = s.read count;
                    len = (mat.width part);
                    push chunks part;
                    pos := pos + len;
                    if len == count then part
                    else
                        mat.concat (Horizontal ())
                           [part, readFromCache (count - len)];
                    fi;
                fi,
        }
    fi;

duplicated copies s = 
//!!! doc fact that original s cannot be used independently of this afterward
// (so maybe name is misleading?)
    if copies < 2 then map \s [1..copies];
    else
        pos = [:];
        lowtide () = head (sort (map (at pos) (keys pos)));
        var hightide = 0;
        var cache = mat.zeroSizeMatrix ();
        syncd = synchronized pos;
        advance i n =
           (formerLow = lowtide ();
            pos[i] := pos[i] + n;
            encroachment = lowtide () - formerLow;
            if encroachment > 0 then
                cache := mat.columnSlice cache encroachment (mat.width cache);
            fi);
        map do instance:
            pos[instance] := 0;
            {
                get position () = syncd \(pos[instance]),
                get channels () = syncd \(s.channels),
                get sampleRate () = syncd \(s.sampleRate),
                get available () = syncd
                  \(case s.available of
                    Known av: Known (av + (hightide - pos[instance]));
                    other: other;
                    esac),
                get finished? () = syncd
                  \(if not s.finished? then false
                    else pos[instance] >= hightide
                    fi),
                read count = syncd
                  \(ready = hightide - pos[instance];
                    if s.finished? and ready <= 0 
                    then mat.zeroSizeMatrix ()
                    else
                        if count > ready then
                            more = s.read (count - ready);
                            cache := mat.concat (Horizontal ()) [cache, more];
                            hightide := hightide + (mat.width more);
                        fi;
                        offset = pos[instance] - (lowtide ());
                        chunk = mat.columnSlice cache offset (offset + count);
                        advance instance (mat.width chunk);
                        chunk;
                    fi),
                close () = syncd
                  \(delete pos instance;
                    if empty? pos then
                        s.close ()
                    fi),
            }
            done [1..copies];
    fi;

zeroPaddedFreqFrames framesize channels =
    // take a multi-channel stream, convert to a series of list of
    // complex frequency-domain frames calculated from input padded to
    // framesize*2, in which each frame contains all channels one
    // after another (not interleaved) [because we lack a complex
    // matrix type]
   (forwardTransform = fft.realForward (framesize * 2);
    do stream:
        padded = 
           (map (mat.resizedTo { rows = channels, columns = framesize * 2 })
               (fr.frames { framesize, hop = framesize } stream));
        map do fr: concat (map forwardTransform (mat.asRows fr)) done padded;
    done);

doFastConvolve irframes sigframes =
   (var history = [];
    irlen = length irframes;
    n = length (head irframes);
//    println "irlen = \(irlen), siglen = \(length sigframes), n = \(n)";
    map do sigf:
//    print ".";
        history := take irlen (sigf::history);
        fold do cc1 cc2: map2 cplx.add cc1 cc2 done
           (list (cplx.zeros n))
           (map2 do irf histf:
                map2 cplx.multiply irf histf;
            done irframes history);
        done sigframes);

splitInto n fr =
   (parts = splitAt n fr;
    if empty? parts.snd then [parts.fst]
    else parts.fst :: splitInto n parts.snd;
    fi);

fastConvolvedWith ir framesize s =
    // prerequisite: ir and s have same number of channels
   (framer = zeroPaddedFreqFrames framesize (mat.height ir);
    irfr = framer (syn.precalculated 1 ir); // rate arg is irrelevant here
    sigfr = framer s;
    ch = s.channels;
    inverseTransform = fft.realInverse (framesize * 2);
    extended = sigfr ++
        map do _: list (cplx.zeros (ch * (framesize + 1))) done [1..length irfr-1];
    cframes = doFastConvolve irfr extended; 
    rframes = (mat.zeroMatrix { rows = ch, columns = framesize * 2}) ::
        map do fr:
            mat.newMatrix (RowMajor ())
               (map inverseTransform (splitInto (framesize+1) fr))
            done cframes;
    fr.streamOverlapping s.sampleRate
        { framesize = framesize * 2, hop = framesize, window = win.boxcar }
        rframes
);

plainConvolvedWith ir s =
    // prerequisite: ir and s have same number of channels
   (var history = mat.toRowMajor
       (mat.zeroMatrix { rows = s.channels, columns = mat.width ir - 1 });
    s with 
    {
        get finished? () =
            s.finished? and (mat.empty? history),
        get available () = 
            case s.available of
            Known n: Known (n + mat.width history);
            other: other;
            esac,
        read count = 
           (// Example: The IR is four samples long; we have three
            // samples in history; two samples are available to read
            // before the stream runs out. That means we can return
            // up to five samples. Caller requests 6.
            signal = s.read count;                     // -> two samples
            siglen = mat.width signal;                 // -> 2
            histlen = mat.width history;               // -> 3
            convlen = min count (siglen + histlen);    // -> 5
            input = mat.resizedTo { rows = s.channels, columns = convlen }
                signal;  // example input now 5 samples, of which 2 are signal
            output = array (map \(new double[convlen]) [1..s.channels]);
            for [0..s.channels - 1] do ch:
                for [0..mat.width input - 1] do i:
                    for [0..mat.width ir - 1] do j:
                        v = 
                            if i >= j then
                                mat.at input ch (i - j)
                            else
                                ix = mat.width ir + i - j - 1;
                                if ix >= histlen then 
                                    0 
                                else
                                    mat.at history ch ix
                                fi
                            fi;
                        output[ch][i] := output[ch][i] + v * (mat.at ir ch j);
                    done;
                done;
            done;
            // Remove from history a number of samples equal to the
            // number returned; add to it a number equal to the number
            // read from source
            extended = mat.concat (Horizontal ()) [history, signal]; // -> 5
            newlen = (histlen + siglen) - convlen; // -> 0
            w = mat.width extended;
            history := mat.columnSlice extended (w - newlen) w;
            mat.newMatrix (RowMajor ()) (map vec.vector output)),
    });

nextPowerOfTwo n =
   (nextPowerOfTwo' p n =
        if p >= n then p
        else nextPowerOfTwo' (p * 2) n
        fi;
    nextPowerOfTwo' 1 n);

//!!! todo: partial application so as to preprocess ir (in fast convolution case)
convolvedWith options ir s = //!!! cheap mono thing here
   (if mat.height ir != s.channels then
        failWith "Signal stream and IR must have same number of channels (\(s.channels) != \(mat.height ir))"
    fi;
    var type = Fast ();
    var framesize = nextPowerOfTwo (mat.width ir);
println "convolvedWith: framesize = \(framesize) for ir width \(mat.width ir)";
    for options \case of
    //!!! todo: test these options
        Fast s: if s then type := Fast () else type := Plain () fi;
        Framesize n: framesize := nextPowerOfTwo n;
        esac;
    case type of
    Fast ():
        fastConvolvedWith ir framesize s;
    Plain ():
        plainConvolvedWith ir s;
    esac);

/**
  Produce a sinc window of width equal to zc zero crossings per half,
  with n samples from peak to first zero crossing, multiplied by a
  Kaiser window with attenuation 𝛼 dB
 */
kaiserSincWindow zc n 𝛼 =
   (sw = win.sinc (n*2) (n*zc*2 + 1);
    kw = win.kaiserForAttenuation 𝛼 (vec.length sw);
    bf.multiply sw kw);

spaced mult s = //!!! mult must be an integer [how to enforce this??]
 //!!! very, very slow
//!!! test, then rewrite to be faster
   (var pos = 0;
    s with
    {
        get position () = pos,
        get available () = 
            case s.available of Known n: Known (n*mult); other: other esac,
        read n =
           (readOne () =
               (offset = pos % mult;
                sample =
                    if offset == 0 then
                        m = s.read 1;
                        if mat.width m == 1 then
                            mat.at m 0 0;
                        else
                            0
                        fi;
                    else
                        0
                    fi; 
                pos := pos + 1;
                sample);
            mat.newRowVector (vec.fromList (map \(readOne ()) [1..n]))),
    });
                
            
/*
   (samples () =
        if s.finished? then []
        else s.read 1 :. samples
        fi;
    fr.streamed s.sampleRate { framesize = mult, hop = mult } 
       (map (mat.resizedTo { rows = s.channels, columns = mult }) (samples ())));
*/        

interpolated factor s = //!!! factor must be an integer [how to enforce this??]
    if factor == 1 then s
    else
        nzc = 13;
        attenuation = 80;
        filter = kaiserSincWindow nzc factor attenuation;
        out = delayedBy (- (nzc * factor))
           (convolvedWith [Framesize 1024]
               (mat.newMatrix (RowMajor ()) (map \filter [1..s.channels]))
               (spaced factor s));
        out with { get sampleRate () = s.sampleRate * factor };
    fi;

picked frac s =
    s with
    {
        get position () = int (s.position / frac),
        get available () =
            case s.available of Known n: Known (int (n/frac)); other: other esac,
        read n =
           (m = s.read (n*frac);
            obtained = int ((mat.width m) / frac);
            mat.flipped
               (mat.newMatrix (ColumnMajor ())
                   (map do c: mat.getColumn (c*frac) m done [0..obtained-1])))
    };

decimated factor s = //!!! factor must be an integer [how to enforce this??]
    if factor == 1 then s
    else
        nzc = 13;
        attenuation = 80;
        filter = kaiserSincWindow nzc factor attenuation;
        filtered =
           (convolvedWith [Framesize 1024]
               (mat.newMatrix (RowMajor ()) (map \filter [1..s.channels])) s);
        out = scaledBy (1/factor)
           (delayedBy (- nzc)
               (picked factor filtered));
        out with { get sampleRate () = s.sampleRate / factor };
    fi;

gcd a b = (c = a % b; if c == 0 then b else gcd b c fi);

resampledTo rate s =
   (g = gcd rate s.sampleRate;
   println "orig = \(s.sampleRate), target = \(rate), g = \(g), up = \(rate/g), down = \(s.sampleRate/g)";
    decimated (s.sampleRate / g) (interpolated (rate/g) s));

{
    withDuration is number -> stream -> stream,
    delayedBy is number -> stream -> stream,
    scaledBy is number -> stream -> stream,
    inverted is stream -> stream,
    mixedTo is number -> stream -> stream,
    sum is list<stream> -> stream = sum',
    mean is list<stream> -> stream,
    difference is stream -> stream -> stream,
    multiplexed is list<stream> -> stream,
    repeated is stream -> stream,
    duplicated is number -> stream -> list<stream>,
    convolvedWith is list<Fast boolean | Framesize number> -> matrix -> stream -> stream,
    kaiserSincWindow, spaced, interpolated, decimated, picked,
    resampledTo,
}

