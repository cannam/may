
// Simple (rather than efficient) definitions of bandlimited wave
// shapes

module may.stream.waves;

{ sinusoid } = load may.stream.syntheticstream;
{ sum, scaledBy } = load may.stream.manipulate;
{ precalculatedRepeated } = load may.stream.syntheticstream;
{ gcd } = load may.mathmisc;

load may.stream.type;

cycleLengthFor rate freq = 
    // The number of samples we can cache and repeat from a wavetable,
    // in order to exactly reproduce a signal of the given frequency
    // at the given samplerate. 
   (if rate == int rate and freq == int freq and rate > 0 and freq > 0 then
        rate / (gcd rate freq)
    else
        period = rate / freq;
        m = find do i: i * period == int (i * period) done [1..rate];
        if empty? m then 0
        else period * (head m)
        fi
    fi);

square' rate freq = 
    sum
       (map do n: 
            m = n*2 + 1;
            scaledBy (1/m)
               (sinusoid rate (m * freq))
            done (0 :: [1 .. int (rate/4 / freq) - 1]));

saw' rate freq =
    sum
       (map do n:
            scaledBy if n % 2 == 0 then -1/n else 1/n fi
               (sinusoid rate (n * freq))
            done [1 .. int (rate/2 / freq)]);

triangle' rate freq = 
    sum
       (map do n: 
            m = n*2 + 1;
            scaledBy if n % 2 == 0 then -1/(m*m) else 1/(m*m) fi
               (sinusoid rate (m * freq))
            done (0 :: [1 .. int (rate/4 / freq) - 1]));

cached f rate freq =
   (n = cycleLengthFor rate freq;
    if n == 0 then
        f rate freq;
    else
        // one could alternatively do
        //   repeated (precalculated rate ((f rate freq).read n))
        // or
        //   repeated (withDuration n (f rate freq))
        precalculatedRepeated rate ((f rate freq).read n);
    fi);

square = cached square';
saw = cached saw';
triangle = cached triangle';

{
    square is number -> number -> stream_t,
    saw is number -> number -> stream_t, 
    triangle is number -> number -> stream_t,
    cycleLengthFor is number -> number -> number,
}

