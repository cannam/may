
module may.stream.test.test_resample;

vec = load may.vector;
bf = load may.vector.blockfuncs;
mat = load may.matrix;
syn = load may.stream.syntheticstream;
manip = load may.stream.manipulate;
resample = load may.stream.resample;
win = load may.signal.window;
waves = load may.stream.waves;
fft = load may.transform.fft;

pl = load may.plot;//!!!

//pl = { plot things = true; };

{ compare, compareUsing, assert, time } = load may.test.test;

//!!! This and gcd should be Somewhere
nextPowerOfTwo n =
   (nextPowerOfTwo' p n =
        if p >= n then p
        else nextPowerOfTwo' (p * 2) n
        fi;
    nextPowerOfTwo' 1 n);

windowedSignalFrom stream nsamps =
   (data = stream.read nsamps;
    windowed = win.windowedRows win.hann data;
    syn.precalculated stream.sampleRate windowed);

compareClose = compareUsing 
    do m1 m2:
        length m1 == length m2 and 
            all id (map2 do v1 v2:
                length v1 == length v2 and
                    all id (map2 do a b: abs(a - b) < 1e-10 done v1 v2)
                done m1 m2);
    done;

[

// Test for duration of decimated stream (does not test contents, that
// happens in the filters tests below).
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).

"dec-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.decimated 2 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 2 and
        compare str.available (Known 4) and
        compare str.finished? false and
       (r = str.read 3;
        println "r = \(r)";
        compare (mat.size r) { rows = 1, columns = 3 }) and
        compare str.position 3 and
        compare str.available (Known 1) and
        compare str.finished? false and
       (r = str.read 3;
        println "r = \(r)";
        compare (mat.size r) { rows = 1, columns = 1 }) and
        compare str.position 4 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

// Test for duration of interpolated stream (does not test contents,
// that happens in the filters tests below)
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).

"int-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.interpolated 2 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 8 and
        compare str.available (Known 16) and
        compare str.finished? false and
        compare (mat.size (str.read 12)) { rows = 1, columns = 12 } and
        compare str.position 12 and
        compare str.available (Known 4) and
        compare str.finished? false and
        compare (mat.size (str.read 12)) { rows = 1, columns = 4 } and
        compare str.position 16 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

// Test for duration of resampled stream (does not test contents,
// that happens in the filters tests below)
// Resampled streams only have accurate duration when their inputs
// have known duration (otherwise they may be rounded up to the
// processing block size).
"resamp-duration": \(
    original = manip.withDuration 8 (syn.precalculatedMono 4 (vec.fromList [1,2,3,4,5,6,7,8]));
    str = resample.resampledTo 6 original;
    compare str.position 0 and
        compare str.channels 1 and
        compare str.sampleRate 6 and
        compare str.available (Known 12) and
        compare str.finished? false and
        compare (mat.size (str.read 9)) { rows = 1, columns = 9 } and
        compare str.position 9 and
        compare str.available (Known 3) and
        compare str.finished? false and
        compare (mat.size (str.read 9)) { rows = 1, columns = 3 } and
        compare str.position 12 and
        compare str.available (Known 0) and
        compare str.finished? true and
        ( str.close (); true )
),

/*
"interpolated-sine": \(
    // Interpolating a windowed sinusoid should give us a windowed sinusoid
    sinusoid = syn.sinusoid 8 2; // 2Hz sine sampled at 8Hz: [ 0, 1, 0, -1 ] etc
    input = windowedSignalFrom sinusoid 16;
    output = resample.interpolated 2 input;
    result = output.read 32;
    reference = syn.sinusoid 16 2;
    expected = (windowedSignalFrom reference 32).read 32;
    compareOutputs a b = compareClose
       (map vec.list (mat.asRows a)) (map vec.list (mat.asRows b));
\() (pl.plot [Vector (mat.getRow 0 result), Vector (mat.getRow 0 expected)]);
println "diff is \(mat.difference result expected)";
\() (pl.plot [Vector (mat.getRow 0 (mat.difference result expected))]);
    compareOutputs result expected;
),

"decimated-sine": \(
    // Decimating a windowed sinusoid should give us a windowed sinusoid
    sinusoid = syn.sinusoid 32 1; // 1Hz sine sampled at 32Hz
    input = windowedSignalFrom sinusoid 400;
    output = resample.decimated 2 input;
//    result = mat.columnSlice (output.read 200) 50 150;
    result = output.read 200;
    reference = syn.sinusoid 16 1;
//    expected = mat.columnSlice (reference.read 200) 50 150;
    expected = (windowedSignalFrom reference 200).read 200;
    compareOutputs a b = compareClose
       (map vec.list (mat.asRows a)) (map vec.list (mat.asRows b));
    if not compareOutputs result expected then
\() (pl.plot [Vector (mat.getRow 0 result), Vector (mat.getRow 0 expected)]);
        println "diff: \(mat.difference result expected)";
\() (    pl.plot [ Vector (mat.getRow 0 (mat.difference result expected)) ] );
	false
    else true fi
),
*/

"resample-spectrum": \(
    // Generate a wave with a lot of harmonics, resample by some
    // ratio, check that the resulting signal has substantially the
    // same magnitude spectrum as the original
    inrate = 44100;
    outrate = 48000;
    freq = 500;
    forms = manip.duplicated 2 (waves.saw inrate freq);
    inform = forms[0];
    outform = resample.resampledTo outrate forms[1];
    sigOf str n =
       (\() (str.read n);
        sig = mat.getRow 0 (str.read n);
        win.windowed win.hann sig);
    incount = inrate;
    outcount = outrate;
    insig = time "read original, \(incount*2) at rate \(inrate)" \(sigOf inform incount);
    outsig = time "read resampled, \(outcount*2) at rate \(outrate)" \(sigOf outform outcount);
    speclen = (min incount outcount) / 2 + 1;
    inmag = bf.divideBy incount (vec.resizedTo speclen (fft.realForwardMagnitude incount insig));
    outmag = bf.divideBy outcount (vec.resizedTo speclen (fft.realForwardMagnitude outcount outsig));
    diff = bf.subtract inmag outmag;
//    compareClose [vec.list inmag] [vec.list outmag] or
        (//println "inmag: \(vec.list inmag)";
         //println "outmag: \(vec.list outmag)";
         //println "diff: \(vec.list diff)";
         println "\nout of range: ";
         var i = 0;
         for (vec.list diff) do d:
             if abs d > 1e-8 then
                 print " * \(d) at \(i) [\(vec.at inmag i) vs \(vec.at outmag i)]\n";
             fi;
             i := i + 1;
         done;
         println "";
//         \() (pl.plot [Vector inmag, Vector outmag]);
//         \() (pl.plot [Vector diff]);
         false);
),


"interpolated-misc": \(
    // Interpolating any signal by N should give a signal in which
    // every Nth sample is the original signal
    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.concat [ data, data ];
    input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
    factor = 3;
    up = resample.interpolated factor input;
    result = mat.getRow 0 (up.read (factor * vec.length data));
    phase = 0;
    a = vec.list data;
    b = map do i: vec.at result (i*factor + phase) done [0..vec.length data - 1];
    compareClose [b] [a];
),

"interpolated-rs-misc": \(
    // Just as above, but using resampledTo instead of interpolated
    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.concat [ data, data ];
    input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
    factor = 3;
    up = resample.resampledTo (factor * input.sampleRate) input;
    result = mat.getRow 0 (up.read (factor * vec.length data));
    phase = 0;
    a = vec.list data;
    b = map do i: vec.at result (i*factor + phase) done [0..vec.length data - 1];
    compareClose [b] [a];
),

/*
"int-dec": \(
    // Interpolating any signal then decimating by the same factor
    // should get us the original back again
    //!!! no, this is phase dependent
//    data = vec.fromList [ 0, 0.1, -0.3, -0.4, -0.3, 0, 0.5, 0.2, 0.8, -0.1 ];
//    data = vec.concat [ data, bf.scaled (5/4) data, bf.scaled (3/4) data, data ];
    data = vec.fromList [ 0, 1, 2, 3 ];
    data = vec.concat [ data, data ];

    factor = 3;

    updown prepad =
       (input = manip.withDuration (vec.length data) (syn.precalculatedMono 4 data);
        intermediate = resample.interpolated factor input;
        output = resample.decimated factor (manip.delayedBy prepad intermediate);
        output.read (vec.length data));

    result = updown 0;
    if not compareClose [vec.list (mat.getRow 0 result)] [vec.list data] then
        \() (pl.plot [Vector data, 
                      Vector (mat.getRow 0 result), 
                      Vector (mat.getRow 0 (updown 1)),
                      Vector (mat.getRow 0 (updown 2))]);
        up = (resample.interpolated 2 (syn.precalculatedMono 4 data)).read 80;
        \() (pl.plot [Vector (mat.getRow 0 up)]);

        false
    else true fi;
),
*/
] is hash<string, () -> boolean>;

